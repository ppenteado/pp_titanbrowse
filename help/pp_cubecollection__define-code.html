<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Wed Jun 22 22:23:05 2016 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>pp_cubecollection__define.pro (Documentation for pp_lib)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="pp_cubecollection__define.pro (Documentation for pp_lib)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;+</span>
<span class="comments">;</span>
<span class="comments">; :Uses: pp_editablecube__define, pp_getcubeheadervalue, pp_extractfields, pp_setcubeheadervalue, pp_readcube__define</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Nov/2009</span>
<span class="comments">;-</span>

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Initializes a pp_cubecollection object, either from a previously built file,</span>
<span class="comments">;    or builds the file from cube files.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    savefile : in, required</span>
<span class="comments">;      The name of the file that either will contain the object's data, or the data will be</span>
<span class="comments">;      read from, depending on the build keyword.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    build : in, optional, default=0</span>
<span class="comments">;      If set, the cubes named in cubefiles are read from disk and the container file is created.</span>
<span class="comments">;      Otherwise, it is assumed the container file was previously created, and the object gets</span>
<span class="comments">;      its data from that file.</span>
<span class="comments">;    cubefiles : in, out, optional</span>
<span class="comments">;      If build is set, a string array with the names of the cube files to read. If absent and build is</span>
<span class="comments">;      set, all cubes found in the current directory (ending with '_eg.cub', '_ir_eg.cub', or '_vis_eg.cub',</span>
<span class="comments">;      depending on the vis and ir keywords) are used, and their names are returned in this keyword. </span>
<span class="comments">;    vis : in, optional, default=0</span>
<span class="comments">;      If set, cubes matching '*_vis_eg.cub' are used when building the container file, instead of '*_eg.cub'.</span>
<span class="comments">;    ir : in, optional, default=0</span>
<span class="comments">;      If set, cubes matching '*_ir_eg.cub' are used when building the container file, instead of '*_eg.cub'.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    See the example on pp_editablecube__define.</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Nov/2009</span>
<span class="comments">;-</span>
<a id="pp_cubecollection::init:source"></a>function pp_cubecollection::init,savefile,build=build,cubefiles=cubefiles,vis=vis,ir=ir,compress=compress,$
  class=class,_ref_extra=ex
compile_opt idl2

ret=0
<span class="comments">;Defaults</span>

class=n_elements(class) ? class : 'pp_editablecube'

compress=n_elements(compress) eq 1 ? compress : 1B
build=n_elements(build) eq 1 ? build : 0
if (n_elements(savefile) eq 0) then begin
  print,'pp_cubecollection: collection file not provided'
  return,0
endif else self.savefile=savefile

idstring='pp_cubecollection_container' <span class="comments">;id to test if savefile was created by this object</span>

error_status=0<span class="comments">;catch,error_status</span>
if (error_status ne 0) then begin
  catch,/cancel
  print,'pp_cubecollection::init : Could not read file "',self.savefile,'"'
  self->cleanup
endif else begin
<span class="comments">;Build savefile</span>
  if build then begin
    ncubes=n_elements(cubefiles)
    suff=keyword_set(vis) ? '_vis_eg.cub' : (keyword_set(ir) ? '_ir_eg.cub' : '_eg.cub') 
    cubefiles=ncubes gt 0 ? cubefiles : file_search('*'+suff,count=ncubes)
    print,ncubes,' cubes found'
    if (ncubes eq 0) then message,'No cubes found to build collection from'
    print,'Building collection file, this may take a long time and use a lot of memory if there are many cubes'
    ocubes=objarr(ncubes)
    for i=0,ncubes-1 do begin
      print,'Reading ',cubefiles[i],' (',strcompress(string(i+1,'/',ncubes,')'),/rem)
      ocubes[i]=obj_new(class,file=cubefiles[i],_strict_extra=ex)
    endfor
<span class="comments">;Build index of heap variables, needed to retrieve individual elements of ocube from savefile</span>
    heapinds=long(strsplit(strjoin(string(ocubes,/print)),'&lt;ObjHeapVar',/regex,/extract))
<span class="comments">;Make savefile</span>
    print,'Writing savefile'
    save,file=savefile,idstring,ncubes,cubefiles,heapinds,ocubes,compress=compress
<span class="comments">;Get rid of the large ocubes array</span>
    obj_destroy,ocubes
  endif
<span class="comments">;Initialize the object to read the savefile</span>
  self.osav=obj_new('idl_savefile',savefile,/relaxed_structure_assignment)
<span class="comments">;Get metadata from savefile, if initializing from it</span>
  if (~build) then begin
    oidstring=idstring
    self.osav->restore,'idstring'
    if (idstring[0] ne oidstring) then message,'Not a pp_cubecollection savefile'
    self.osav->restore,['ncubes','cubefiles','heapinds']
<span class="comments">;Make a dummy editablecube object just to make sure its methods get compiled</span>
    a=obj_new('pp_editablecube',file='')
    obj_destroy,a
  endif
<span class="comments">;Save fields into self</span>
  self.ncubes=ncubes
  self.cubefiles=ptr_new(cubefiles,/no_copy)
  self.heapinds=ptr_new(heapinds,/no_copy)
  obj_destroy,self.osav
  ret=1
endelse
return,ret
end

<a id="pp_cubecollection::cleanup:source"></a>pro pp_cubecollection::cleanup
compile_opt idl2,hidden
ptr_free,self.cubefiles,self.heapinds
obj_destroy,self.osav
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Retrieves selected cubes from the container, by their indexes or filenames.</span>
<span class="comments">;    </span>
<span class="comments">; :Returns:</span>
<span class="comments">;    If index or name are scalars, the object with the selected cube. If they are arrays,</span>
<span class="comments">;    an object array of the same dimensions, with each containing the corresponding object.</span>
<span class="comments">;    If a requested object is not found, a null object is returned in its place.</span>
<span class="comments">;    If both index and name are provided, the index values are used to select the cubes,</span>
<span class="comments">;    with their names returned in names.</span>
<span class="comments">;    </span>
<span class="comments">;    The object references returned are to the same objects: no copy is made on successive calls</span>
<span class="comments">;    to get the same cube. A copy can be made making a new pp_editablecube object from the returned</span>
<span class="comments">;    object reference, as shown in the example.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    index : in, optional</span>
<span class="comments">;      The index numbers of the cubes to retrieve.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    name : in, optional</span>
<span class="comments">;      The names of the cubes to retrieve.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    See the example on pp_editablecube__define.</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Nov/2009</span>
<span class="comments">;-</span>
<a id="pp_cubecollection::getcube:source"></a>function pp_cubecollection::getcube,index,name=name
compile_opt idl2
ni=n_elements(index)
nn=n_elements(name)
if (ni eq 0) then begin
  if (nn eq 0) then ret=obj_new() else begin
    ret=objarr(nn)
    index=lonarr(nn)
    for i=0,nn-1 do index[i]=(where(*self.cubefiles eq name[i]))[0]
    ni=nn
  endelse
endif else begin
  ret=objarr(ni)
  name=strarr(ni)
endelse
sav=obj_valid(self.osav)
if (~sav) then self.osav=obj_new('idl_savefile',self.savefile,/relaxed_structure_assignment)
for i=0,ni-1 do begin
   if (index[i] ge 0)&&(index[i] lt self.ncubes) then begin
    self.osav->restore,(*self.heapinds)[index[i]],/object_heapvar,new_heapvar=tmp
    ret[i]=tmp
    name[i]=tmp->getproperty(/file)
  endif
endfor
if (~sav) then obj_destroy,self.osav
return,ret
end

<a id="pp_cubecollection::opensav:source"></a>pro pp_cubecollection::opensav,close=close
compile_opt idl2
if keyword_set(close) then obj_destroy,self.osav else if (~obj_valid(self.osav)) $
 then self.osav=obj_new('idl_savefile',self.savefile,/relaxed_structure_assignment)
end


<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Returns a string array with the filenames of all cubes in the collection.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    ncubes, out: optional</span>
<span class="comments">;      The number of cubes contained in the collection.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    See the example on pp_editablecube__define.</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Nov/2009</span>
<span class="comments">;-</span>
<a id="pp_cubecollection::filenames:source"></a>function pp_cubecollection::filenames,ncubes=ncubes
compile_opt idl2
ncubes=self.ncubes
return,*self.cubefiles
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Object that contains a collection of cubes, that can be retrieved as pp_editablecube objects</span>
<span class="comments">;    by their names or indexes. The cubes are stored in a savefile instead of memory, so initializing</span>
<span class="comments">;    from an existing file is a quick and light operation. The cube data is only read when that particular</span>
<span class="comments">;    cube is to be retrieved, and only those selected to be retrieved are read from the file. Thus a savefile</span>
<span class="comments">;    made by a pp_cubecollecion object is a portable, convenient and efficient way to store and carry several cubes.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    Initially, a container file must be built from cube files. To take all files ending with</span>
<span class="comments">;    '_ir_eg.cub' from the current directory (which can be a long operation and use a lot of</span>
<span class="comments">;    memory if there are many cubes)::</span>
<span class="comments">;    </span>
<span class="comments">;       a=obj_new('pp_cubecollection','testcollection.sav',/build,/ir)</span>
<span class="comments">;       </span>
<span class="comments">;    If a collection savefile already exists, no matter how large it is, loading it is a quick</span>
<span class="comments">;    and light operation, because only meta-data is read::</span>
<span class="comments">;     </span>
<span class="comments">;      a=obj_new('pp_cubecollection','testcollection.sav')</span>
<span class="comments">;       </span>
<span class="comments">;    To get the names of the cubes present in the collection::</span>
<span class="comments">;     </span>
<span class="comments">;      print,a->filenames(ncubes=ncubes)</span>
<span class="comments">;      ;CM_1467426144_5_ir_eg.cub CM_1467426479_1_ir_eg.cub CM_1467426798_1_ir_eg.cub CM_1467427145_1_ir_eg.cub</span>
<span class="comments">;      ;(...)</span>
<span class="comments">;      print,ncubes</span>
<span class="comments">;      57</span>
<span class="comments">;</span>
<span class="comments">;    To retrieve the first 3 cubes::</span>
<span class="comments">;     </span>
<span class="comments">;      b=a->getcube([0,1,2])</span>
<span class="comments">;       </span>
<span class="comments">;    To retrieve the cube of name CM_1467426479_1_ir_eg::</span>
<span class="comments">;     </span>
<span class="comments">;      c=a->getcube(name='CM_1467426479_1_ir_eg.cub')</span>
<span class="comments">;       </span>
<span class="comments">;     b[1] and c are the same object::</span>
<span class="comments">;     </span>
<span class="comments">;       ;print,b[1],c</span>
<span class="comments">;       </span>
<span class="comments">;    To make a copy of that object, to keep after the collection is destroyed::</span>
<span class="comments">;     </span>
<span class="comments">;      d=obj_new('pp_editablecube',c)</span>
<span class="comments">;      print,obj_valid(b),obj_valid(c),obj_valid(d)</span>
<span class="comments">;      ;1   1   1</span>
<span class="comments">;      ;1</span>
<span class="comments">;      ;1</span>
<span class="comments">;      obj_destroy,b</span>
<span class="comments">;      print,obj_valid(b),obj_valid(c),obj_valid(d)</span>
<span class="comments">;      ;0   0   0</span>
<span class="comments">;      ;0</span>
<span class="comments">;      ;1</span>
<span class="comments">;       </span>
<span class="comments">;    Get rid of the collection once it is done with. This does not affect the savefile,</span>
<span class="comments">;    which can be used to reobtain this collection in the future::</span>
<span class="comments">;     </span>
<span class="comments">;      obj_destroy,a</span>
<span class="comments">;      </span>
<span class="comments">;    See pp_editablecube__define for examples on how to use the cube objects.</span>
<span class="comments">;</span>
<span class="comments">; :Uses: pp_editablecube__define, pp_getcubeheadervalue, pp_extractfields, pp_setcubeheadervalue, pp_readcube__define</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Nov/2009</span>
<span class="comments">;-</span>
<a id="pp_cubecollection__define:source"></a>pro pp_cubecollection__define
compile_opt idl2
void={pp_cubecollection,savefile:'',ncubes:0L,cubefiles:ptr_new(),heapinds:ptr_new(),osav:obj_new()}
end
</code>
    </div>
  </body>
</html>