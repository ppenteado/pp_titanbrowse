<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Wed Jun 22 22:23:06 2016 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>pp_editablecube__define.pro (Documentation for pp_lib)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="pp_editablecube__define.pro (Documentation for pp_lib)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;+</span>
<span class="comments">; :Uses: pp_getcubeheadervalue, pp_extractfields, pp_buffered_vector, pp_setcubeheadervalue</span>
<span class="comments">; </span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Oct/2009</span>
<span class="comments">;-</span>

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Initializes am editablecube object, either from a readcube object, or from a file.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    orcube : in, optional</span>
<span class="comments">;      A readcube or editablecube object from which a copy will be created to be edited in this object. The</span>
<span class="comments">;      original object is unchanged.</span>
<span class="comments">;    file : in, optional</span>
<span class="comments">;      The filename from which to read the cube directly. If provided, orcube is ignored.</span>
<span class="comments">;    special : in, optional, default=0</span>
<span class="comments">;      Same as pp_readcube::init's special:</span>
<span class="comments">;      </span>
<span class="comments">;      Determines the type of special value replacement to use:</span>
<span class="comments">;      </span>
<span class="comments">;      0 uses the default special values</span>
<span class="comments">;      </span>
<span class="comments">;      1 uses the special values found in the header</span>
<span class="comments">;      </span>
<span class="comments">;      2 disables special value replacement</span>
<span class="comments">;      </span>
<span class="comments">;    preservespecial : in, optional, default=0</span>
<span class="comments">;      If set, the special values used in the original cube are kept (unless data type changes).</span>
<span class="comments">;      Otherwise, default values are used.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    See the example on pp_editablecube__define.</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Oct/2009</span>
<span class="comments">;-</span>
<a id="pp_editablecube::init:source"></a>function pp_editablecube::init,orcube=orcube,file=file,special=special,preservespecial=preservespecial
compile_opt idl2,hidden

ret=0
<span class="comments">;If file is provided, read the cube with the methods inherited from readcube</span>
if (n_elements(file) eq 1) then ret=self->pp_readcube::init(file,special=special) else begin
<span class="comments">;If a readcube/editablecube object is provided, make a copy of its data</span>
  orcube->getproperty,all=all
  self.file=all.file
  self.special=all.special
  self.labels=ptr_new(all.labels)
  self.tlabels=ptr_new(strtrim(all.labels,2))
  self.history=ptr_new(all.history)
  self.thistory=ptr_new(strtrim(all.history,2))
  self.core=ptr_new(all.core)
  if (all.nback gt 0) then self.backplanes=ptr_new(all.backplanes)
  if (all.nside gt 0) then self.sideplanes=ptr_new(all.sideplanes)
  if (all.nbottom gt 0) then self.bottomplanes=ptr_new(all.bottomplanes)
  self.info=all.info
  self.raw=ptr_new(all.raw)
  self.wavs=ptr_new(all.wavelengths)
  self.bnames=ptr_new(all.backnames)
  self.snames=ptr_new(all.sidenames)
  self.bonames=ptr_new(all.bottomnames)
  self.units=all.units
  self.bunits=ptr_new(all.backunits)
  self.bunits=ptr_new(all.sideunits)
  self.bunits=ptr_new(all.bottomunits)
  ret=1
endelse
if (ret eq 0) then return,ret
<span class="comments">;Keep an unaltered copy of the original header parts</span>
self.oldlabels=ptr_new(*self.labels)
self.oldhistory=ptr_new(*self.history)
<span class="comments">;Count the length of the old header parts (in bytes)</span>
self.llength=strlen(strjoin(*self.labels))+2L*n_elements(*self.labels)
self.oldllength=self.llength
self.hlength=strlen(strjoin(*self.history))+2L*n_elements(*self.history)
self.oldhlength=self.hlength
<span class="comments">;Count the length of the raw binary part</span>
self.binlength=n_elements(*self.raw)*self.info.bytes
<span class="comments">;Set the treatment to do to special value labels if type changes</span>
if (n_elements(preservespecial) eq 1) then self.preservespecial=preservespecial

return,ret
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Changes one or more properties of the cube, according to the data given in the</span>
<span class="comments">;    keywords. All keywords are optional.</span>
<span class="comments">;</span>
<span class="comments">; :Returns:</span>
<span class="comments">;    The keywords marked as both in and out, if undefined or invalid at input,</span>
<span class="comments">;    return the assigned default values to their content. Otherwise, all keywords</span>
<span class="comments">;    are input only and unchanged.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    core : in, optional</span>
<span class="comments">;      An array to replace the core data with. Can be of any size, but must be 3D,</span>
<span class="comments">;      and can be of any numeric type. The object's data type gets replaced by the</span>
<span class="comments">;      type of core, if it is different. This is the only way to change the cube's</span>
<span class="comments">;      data type. To remove existing suffixes, change the 3 core dimensions without</span>
<span class="comments">;      providing corresponding suffix arrays.</span>
<span class="comments">;    backplanes : in, optional</span>
<span class="comments">;      An array to replace the backplana data with. Must have the first two dimensions</span>
<span class="comments">;      equal to the cube's core, can have any number of planes (must be 3D). Most useful</span>
<span class="comments">;      to add new backplanes.</span>
<span class="comments">;    sideplanes : in, optional</span>
<span class="comments">;      An array to replace the sideplane data with. Must have the last two dimensions</span>
<span class="comments">;      equal to the cube's core, can have any number of planes (must be 3D).</span>
<span class="comments">;    bottomplanes : in, optional</span>
<span class="comments">;      An array to replace the bottom data with. Must have the first and last dimensions</span>
<span class="comments">;      equal to the cube's core, can have any number of planes (must be 3D).</span>
<span class="comments">;    backnames : in, out, optional</span>
<span class="comments">;      A string array with each element containing the name of each backplane. If the number</span>
<span class="comments">;      of backplanes is changed and this is not provided, the backplane names get changed to</span>
<span class="comments">;      default values.</span>
<span class="comments">;    sidenames : in, out, optional</span>
<span class="comments">;      A string array with each element containing the name of each sideplane. If the number</span>
<span class="comments">;      of backplanes is changed and this is not provided, the sideplane names get changed to</span>
<span class="comments">;      default values.</span>
<span class="comments">;    bottomnames : in, out, optional</span>
<span class="comments">;      A string array with each element containing the name of each bottomplane. If the number</span>
<span class="comments">;      of backplanes is changed and this is not provided, the bottomplane names get changed to</span>
<span class="comments">;      default values.</span>
<span class="comments">;    wavelengths : in, out, optional</span>
<span class="comments">;      A string array where each element is the wavelength of each core band. If the number of</span>
<span class="comments">;      core bands is changed and this is not provided, the wavelengths get changed to their</span>
<span class="comments">;      default value 'UNKNONW'.</span>
<span class="comments">;    backunits : in, out, optional</span>
<span class="comments">;      A string array with each element containing the name of each backplane's unit. If the number</span>
<span class="comments">;      of backplanes is changed and this is not provided, the backplane units get changed to</span>
<span class="comments">;      default values 'UNKNOWN'.</span>
<span class="comments">;    sideunits : in, out, optional</span>
<span class="comments">;      A string array with each element containing the name of each sideplane's unit. If the number</span>
<span class="comments">;      of backplanes is changed and this is not provided, the sideplane units get changed to</span>
<span class="comments">;      default values 'UNKNOWN'.</span>
<span class="comments">;    bottomunits : in, out, optional</span>
<span class="comments">;      A string array with each element containing the name of each bottomplane's unit. If the number</span>
<span class="comments">;      of backplanes is changed and this is not provided, the bottomplane units get changed to</span>
<span class="comments">;      default values 'UNKNOWN'.</span>
<span class="comments">;    wavelengthunits : in, optional</span>
<span class="comments">;      A string array with the name of the core bands unit.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    See the example on pp_editablecube__define.</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Oct/2009</span>
<span class="comments">;-</span>
<a id="pp_editablecube::setproperty:source"></a>pro pp_editablecube::setproperty,core=core,$
 backplanes=backplanes,sideplanes=sideplanes,bottomplanes=bottomplanes,$
 backnames=bnames,sidenames=snames,bottomnames=bonames,wavelengths=wavs,$
 backunits=bunits,sideunits=sunits,bottomunits=bounits,wavelengthunits=wunits
compile_opt idl2

typechanged=0
dimschanged=[0,0,0]
corechange=(size(core,/n_dimensions) eq 3)
backchange=(size(backplanes,/n_dimensions) eq 3)
sidechange=(size(sideplanes,/n_dimensions) eq 3)
bottomchange=(size(sideplanes,/n_dimensions) eq 3)

<span class="comments">;Update the core if provided</span>
if corechange then self->updatecore,core,dimschanged,typechanged
anydimschanged=(total(dimschanged) ne 0)
oldsuffdims=self.info.suffdims
<span class="comments">;Update the backplanes if provided</span>
if backchange||dimschanged[0]||dimschanged[1]||typechanged then self->updatesuffix,suffix=backplanes,'BAND',2,dimschanged,typechanged
<span class="comments">;Update the sideplanes if provided</span>
if sidechange||dimschanged[1]||dimschanged[2]||typechanged then self->updatesuffix,suffix=sideplanes,'SAMPLE',0,dimschanged,typechanged
<span class="comments">;Update the bottomplanes if provided</span>
if bottomchange||dimschanged[0]||dimschanged[2]||typechanged then self->updatesuffix,suffix=bottomplanes,'LINE',1,dimschanged,typechanged

<span class="comments">;Fix suffix dimension information, if it changed</span>
if (~array_equal(self.info.suffdims,oldsuffdims)) then begin
  self.info.dims=self.info.coredims+self.info.suffdims
  pp_setcubeheadervalue,*self.labels,'SUFFIX_ITEMS',self.info.suffdims
endif

<span class="comments">;Replace the raw data, if necessary</span>
if (corechange||backchange||sidechange||bottomchange) then begin
    ptr_free,self.raw
    raw=make_array(self.info.dims,type=self.info.datatype,/nozero)
    special=self->getspecialvalues(default=~self.preservespecial)
    raw[*]=special.null
    cd=self.info.coredims
    sd=self.info.suffdims
    raw[0:cd[0]-1,0:cd[1]-1,0:cd[2]-1]=*self.core
    if (sd[2] gt 0) then raw[0:cd[0]-1,0:cd[1]-1,cd[2]:cd[2]+sd[2]-1]=*self.backplanes
    if (sd[0] gt 0) then raw[cd[0]:cd[0]+sd[0]-1,0:cd[1]-1,0:cd[2]-1]=*self.sideplanes
    if (sd[1] gt 0) then raw[0:cd[0]-1,cd[1]:cd[1]+sd[1]-1,0:cd[2]-1]=*self.bottomplanes
    byteorder,raw,swap_if_big_endian=self.info.littleendian,$
     swap_if_little_endian=~self.info.littleendian
    self.raw=ptr_new(raw,/no_copy)
endif

<span class="comments">;Update the wavelength units if provided</span>
if (n_elements(wunits) eq 1) then begin
  self.wunits=wunits
  pp_setcubeheadervalue,*self.labels,'CORE_UNIT',self.wunits
endif
<span class="comments">;Update the suffix units if provided</span>
if (self.info.suffdims[2] gt 0) then begin
  *self.bunits=(n_elements(bunits) eq self.info.suffdims[2]) ? bunits : replicate('UNKNOWN',self.info.suffdims[2])
  pp_setcubeheadervalue,*self.labels,'BAND_SUFFIX_UNIT',*self.bunits
endif
if (self.info.suffdims[0] gt 0) then begin
  *self.sunits=(n_elements(sunits) eq self.info.suffdims[0]) ? sunits : replicate('UNKNOWN',self.info.suffdims[0])
  pp_setcubeheadervalue,*self.labels,'SAMPLE_SUFFIX_UNIT',*self.sunits
endif
if (self.info.suffdims[1] gt 0) then begin
  *self.bounits=(n_elements(bounits) eq self.info.suffdims[1]) ? bounits : replicate('UNKNOWN',self.info.suffdims[1])
  pp_setcubeheadervalue,*self.labels,'LINE_SUFFIX_UNIT',*self.info.bounits
endif

<span class="comments">;Update the wavelengths if provided</span>
if dimschanged[2]||(n_elements(wavs) gt 0) then self->updatedatainfo,names=wavs,/core
<span class="comments">;Update names of backplanes if provided</span>
if (oldsuffdims[2] ne self.info.suffdims[2])||(n_elements(bnames) gt 0) then $
 self->updatedatainfo,names=bnames,type='BAND'
<span class="comments">;Update names of sideplanes if provided</span>
if (oldsuffdims[0] ne self.info.suffdims[0])||(n_elements(snames) gt 0) then $
 self->updatedatainfo,names=snames,type='SAMPLE'
<span class="comments">;Update names of bottomplanes if provided</span>
if (oldsuffdims[1] ne self.info.suffdims[1])||(n_elements(bonames) gt 0) then $
 self->updatedatainfo,names=bonames,type='LINE'
<span class="comments">;Fix file parts location information, if necessary</span>
self->updatelocations
<span class="comments">;Make the new trimmed version of the header</span>
*self.tlabels=strtrim(*self.labels,2)

end

<a id="pp_editablecube::updatedatainfo:source"></a>pro pp_editablecube::updatedatainfo,names=names,type=type,core=core
compile_opt idl2,hidden
<span class="comments">;Updates the given names of suffix planes or the band wavelengths (if core is set).</span>
<span class="comments">;Type specifies the type of suffix: 'BAND' for backplane, 'SAMPLE' for sideplane, 'LINE' for bottomplane.</span>
<span class="comments">;Updates are done in fields of self and in the labels</span>

<span class="comments">;Defaults</span>
core=n_elements(core) eq 1 ? core : 0

if (core) then begin
  *self.wavs=(n_elements(wavs) eq self.info.coredims[2]) ? wavs : replicate ('UNKNOWN',self.info.coredims[2])
   pp_setcubeheadervalue,*self.labels,'BAND_BIN_CENTER',*self.wavs
endif else begin
  case type of
   'BAND' : begin & nsuf=self.info.suffdims[2] & ptr=self.bnames & end
   'SAMPLE' : begin & nsuf=self.info.suffdims[0] & ptr=self.snames & end
   'LINE' : begin & nsuf=self.info.suffdims[1] & ptr=self.bonames & end
  endcase 
  if ptr_valid(ptr) then begin
    *ptr=(n_elements(names) eq nsuf) ? names : 'UNKNOWN_'+strtrim(sindgen(nsuf),2)
    pp_setcubeheadervalue,*self.labels,type+'_SUFFIX_NAME',*ptr
  endif
endelse
end

<a id="pp_editablecube::updatesuffix:source"></a>pro pp_editablecube::updatesuffix,suffix=suffix,name,ind,dimschanged,typechanged
compile_opt idl2,hidden
<span class="comments">;Updates the given data (suffix) in the suffix type selected by</span>
<span class="comments">;name: 'BAND' for backplanes, 'SAMPLE' for sideplanes, 'LINE' for bottomplanes.</span>
<span class="comments">;ind selects the corresponding dimension in the suffix (2 for backplanes,</span>
<span class="comments">;0 for sideplanes, 1 for bottomplanes.</span>
<span class="comments">;dimschanged and typechanged signal that either the dimensions or the type</span>
<span class="comments">;of this backplane were changed, so the corresponding fields and labels must</span>
<span class="comments">;be changed. </span>

<span class="comments">;Constants</span>
suffixlabels=['_SUFFIX_NAME','_SUFFIX_UNIT','_SUFFIX_ITEM_TYPE',$
 '_SUFFIX_ITEM_BYTES','_SUFFIX_BASE','_SUFFIX_MULTIPLIER',$
 '_SUFFIX_VALID_MINIMUM','_SUFFIX_NULL','_SUFFIX_LOW_REPR_SAT',$
 '_SUFFIX_LOW_INSTR_SAT','_SUFFIX_HIGH_INSTR_SAT','_SUFFIX_HIGH_REPR_SAT']
case name of
  'BAND' : begin & ptrs=[self.bnames,self.backplanes,self.bunits] & dim=2 & end
  'SAMPLE': begin & ptrs=[self.snames,self.sideplanes,self.sunits] & dim=0 & end
  'LINE' : begin & ptrs=[self.bonames,self.bottomplanes,self.bounits] & dim=1 & end
endcase

szs=size(suffix,/l64)
if (szs[0] eq 3) then begin
<span class="comments">;Replace the suffix data</span>
  tmp=make_array(szs[1:3],type=self.info.datatype)
  tmp[*]=suffix
  if ptr_valid(ptrs[1]) then *(ptrs[1])=temporary(tmp) else begin <span class="comments">;If suffix plane is being created, its pointers are null</span>
    ptrs[1]=ptr_new(tmp,/no_copy)
    tmp=replicate('UNKNOWN',szs[ind+1])
    ptrs[0]=ptr_new(tmp)
    ptrs[2]=ptr_new(tmp,/no_copy)
    case name of
      'BAND' : begin & self.bnames=ptrs[0] & self.backplanes=ptrs[1] & self.bunits=ptrs[2] & end 
      'SAMPLE': begin & self.snames=ptrs[0] & self.sideplanes=ptrs[1] & self.sunits=ptrs[2] & end
      'LINE' : begin & self.bonames=ptrs[0] & self.bottomplanes=ptrs[1] & self.bounits=ptrs[2] & end
    endcase  
  endelse
<span class="comments">;Replace type information, if necessary </span>
  if (typechanged || (szs[ind+1] ne self.info.suffdims[ind])) then begin
    pp_setcubeheadervalue,*self.labels,name+'_SUFFIX_ITEM_BYTES',replicate(self.info.bytes,szs[ind+1])
    pp_setcubeheadervalue,*self.labels,name+'_SUFFIX_ITEM_TYPE',replicate(self.info.type,szs[ind+1])
    pp_setcubeheadervalue,*self.labels,name+'_SUFFIX_BASE',replicate(0.0,szs[ind+1])
    pp_setcubeheadervalue,*self.labels,name+'_SUFFIX_MULTIPLIER',replicate(1.0,szs[ind+1])
<span class="comments">;Fix the special values information, if necessary</span>
    special=self->getspecialvalues(default=typechanged)
    pp_setcubeheadervalue,*self.labels,name+'_SUFFIX_VALID_MINIMUM',$
     replicate((self.info.bytes lt 4 ? special.valid_min : string(special.valid_min,format='("16#",Z08,"#")')),szs[ind+1])
    pp_setcubeheadervalue,*self.labels,name+'_SUFFIX_NULL',$
     replicate((self.info.bytes lt 4 ? special.null : string(special.null,format='("16#",Z08,"#")')),szs[ind+1])
    pp_setcubeheadervalue,*self.labels,name+'_SUFFIX_LOW_REPR_SAT',$
     replicate((self.info.bytes lt 4 ? special.low_repr_sat : string(special.low_repr_sat,format='("16#",Z08,"#")')),szs[ind+1])
    pp_setcubeheadervalue,*self.labels,name+'_SUFFIX_LOW_INSTR_SAT',$
     replicate((self.info.bytes lt 4 ? special.low_instr_sat : string(special.low_instr_sat,format='("16#",Z08,"#")')),szs[ind+1])
    pp_setcubeheadervalue,*self.labels,name+'_SUFFIX_HIGH_INSTR_SAT',$
     replicate((self.info.bytes lt 4 ? special.high_instr_sat : string(special.high_instr_sat,format='("16#",Z08,"#")')),szs[ind+1])
    pp_setcubeheadervalue,*self.labels,name+'_SUFFIX_HIGH_REPR_SAT',$
     replicate((self.info.bytes lt 4 ? special.high_repr_sat : string(special.high_repr_sat,format='("16#",Z08,"#")')),szs[ind+1])
  endif
  self.info.suffdims[ind]=szs[ind+1]
endif else begin <span class="comments">;Get rid of information for that suffix</span>
  for i=0,n_elements(suffixlabels)-1 do pp_setcubeheadervalue,*self.labels,$
   name+suffixlabels[i]
  ptr_free,ptrs[0:1]
  self.info.suffdims[ind]=0L
endelse
end

<a id="pp_editablecube::updatecore:source"></a>pro pp_editablecube::updatecore,core,dimschanged,typechanged
compile_opt idl2,hidden
<span class="comments">;Updates the given core array into the self fields and the labels.</span>
<span class="comments">;dimschanged and typechanged signal that either the dimensions or the type</span>
<span class="comments">;of this backplane were changed, so the corresponding fields and labels must</span>
<span class="comments">;be changed.</span>

<span class="comments">;Replace the core array</span>
*self.core=core
szc=size(core,/l64)
newdims=szc[1:3]
if ~array_equal(newdims,self.info.coredims) then begin <span class="comments">;Must change a bunch of things if core dimensions changed</span>
  dimschanged=newdims ne self.info.coredims <span class="comments">;Mark which dimensions have changed</span>
<span class="comments">;Replace the dimension information</span>
  self.info.coredims=newdims
  self.info.dims=self.info.coredims+self.info.suffdims
  pp_setcubeheadervalue,*self.labels,'CORE_ITEMS','('+string(newdims,format='(3(I0,:,","))')+')'    
endif
<span class="comments">;Replace the type information, if necessary</span>
typechanged=szc[4] ne self.info.datatype
if typechanged then begin
  self.info.type=self.info.littleendian ? 'PC_' : 'SUN_'
  oldbytes=self.info.bytes
  case szc[4] of
    1 : begin & self.info.type+='INTEGER' & self.info.bytes=1 & end
    2 : begin & self.info.type+='INTEGER' & self.info.bytes=2 & end
    3 : begin & self.info.type+='INTEGER' & self.info.bytes=3 & end
    4 : begin & self.into.type+='REAL' & self.info.bytes=4 & end
    5 : begin & self.info.type+='REAL' & self.info.bytes=8 & end
    else : begin & self.into.type+='INTEGER' & self.info.bytes=8 & end
  endcase
  self.info.datatype=szc[4]
<span class="comments">;Fix the label type information</span>
  pp_setcubeheadervalue,*self.labels,'CORE_ITEM_TYPE',self.info.type
  pp_setcubeheadervalue,*self.labels,'CORE_ITEM_BYTES',self.info.bytes
  pp_setcubeheadervalue,*self.labels,'SUFFIX_BYTES',self.info.bytes
<span class="comments">;Fix the special values information</span>
  special=self->getspecialvalues(/default)
<span class="comments">;Fix the special values information, if necessary</span>
  special=self->getspecialvalues(default=typechanged)
  pp_setcubeheadervalue,*self.labels,'CORE_VALID_MINIMUM',$
   replicate(self.info.bytes lt 4 ? special.valid_min : string(special.valid_min,format='("16#",Z08,"#")'),szc[3])
  pp_setcubeheadervalue,*self.labels,'CORE_NULL',$
   replicate(self.info.bytes lt 4 ? special.null : string(special.null,format='("16#",Z08,"#")'),szc[3])
  pp_setcubeheadervalue,*self.labels,'CORE_LOW_REPR_SAT',$
   replicate(self.info.bytes lt 4 ? special.low_repr_sat : string(special.low_repr_sat,format='("16#",Z08,"#")'),szc[3])
  pp_setcubeheadervalue,*self.labels,'CORE_LOW_INSTR_SAT',$
   replicate(self.info.bytes lt 4 ? special.low_instr_sat : string(special.low_instr_sat,format='("16#",Z08,"#")'),szc[3])
  pp_setcubeheadervalue,*self.labels,'CORE_HIGH_INSTR_SAT',$
   replicate(self.info.bytes lt 4 ? special.high_instr_sat : string(special.high_instr_sat,format='("16#",Z08,"#")'),szc[3])
  pp_setcubeheadervalue,*self.labels,'CORE_HIGH_REPR_SAT',$
   replicate(self.info.bytes lt 4 ? special.high_repr_sat : string(special.high_repr_sat,format='("16#",Z08,"#")'),szc[3])
endif
end

<a id="pp_editablecube::updatelocations:source"></a>pro pp_editablecube::updatelocations
compile_opt idl2,hidden
<span class="comments">;Verifies if the length and locations of the label, history and binary</span>
<span class="comments">;parts have changed, and if so, updates the necessary information in the self fields</span>
<span class="comments">;and in the labels.</span>

<span class="comments">;Determine if label part has changed in length</span>
self.llength=strlen(strjoin(*self.labels))+2L*n_elements(*self.labels)
changelab=self.llength ne self.oldllength

<span class="comments">;Determine if history part has changed in length</span>
self.hlength=strlen(strjoin(*self.history))+2L*n_elements(*self.history)
changehist=self.hlength ne self.oldhlength

<span class="comments">;Determine if binary part has changed in length</span>
self.binlength=n_elements(*self.raw)*self.info.bytes
changebin=self.oldbinlength ne self.binlength

<span class="comments">;Update location fields</span>
self.info.labelrecords>=(1+ceil(double(self.llength)/self.info.recordbytes,/l64))
self.info.historyrecords>=ceil(double(self.hlength)/self.info.recordbytes,/l64)
self.info.binaryrecords=ceil(double(self.binlength)/self.info.recordbytes,/l64)
self.info.historystart=self.info.labelrecords
self.info.binarystart=self.info.historystart+self.info.labelrecords
self.info.filerecords=self.info.labelrecords+self.info.historyrecords+self.info.binaryrecords

<span class="comments">;Replace the labels</span>
pp_setcubeheadervalue,*self.labels,'FILE_RECORDS',self.info.filerecords
pp_setcubeheadervalue,*self.labels,'LABEL_RECORDS',self.info.labelrecords
pp_setcubeheadervalue,*self.labels,'\^HISTORY',self.info.historystart+1
pp_setcubeheadervalue,*self.labels,'\^QUBE',self.info.binarystart+1

<span class="comments">;Update label length after the location labels were written</span>
self.llength=strlen(strjoin(*self.labels))+2L*n_elements(*self.labels)
<span class="comments">;Replace the current lengths</span>
self.oldllength=self.llength
self.oldhlength=self.hlength
self.oldbinlength=self.binlength

end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Changes values contained in the label or history part of the cube header.</span>
<span class="comments">;    Can set values of exisiting keys, add new keys, remove exisitng keys, or</span>
<span class="comments">;    just append lines to the header.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    key : in, optional</span>
<span class="comments">;      Key name to be edited.</span>
<span class="comments">;    value : in, optional</span>
<span class="comments">;      Value to be assigned to the named key. If absent, the key is removed.</span>
<span class="comments">;    append : in, optional</span>
<span class="comments">;      Passed to pp_setcubeheadervalue as is.</span>
<span class="comments">;      A string scalar or array of lines to be inserted into the header. If provided, key and value are</span>
<span class="comments">;      ignored. No processing is done on the given lines, it is the user's responsability to ensure they</span>
<span class="comments">;      are valid.</span>

<span class="comments">;    history : in, optional, default=0</span>
<span class="comments">;      If set, editing is done to the history part of the header, instead of the label part.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    See the example on pp_editablecube__define.</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Oct/2009</span>
<span class="comments">;-</span>
<a id="pp_editablecube::headeredit:source"></a>pro pp_editablecube::headeredit,key=key,value=value,append=append,history=hist
compile_opt idl2

<span class="comments">;Defaults</span>
hist=n_elements(hist) eq 1 ? hist : 0

tmp=hist ? *self.history : *self.labels
if (n_elements(append) gt 0) then pp_setcubeheadervalue,tmp,append=append else begin
  if (n_elements(value) gt 0) then pp_setcubeheadervalue,tmp,key,value else pp_setcubeheadervalue,tmp,key
endelse
if (hist) then *self.history=tmp else *self.labels=tmp

end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Writes the cube in the object to a cube file.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    filename, in, optional</span>
<span class="comments">;      The name of the file to which the cube will be written. Optional only</span>
<span class="comments">;      if the object already contains a name in the newfile field from a previous</span>
<span class="comments">;      call of write.</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    format : in, optional, default='fits'</span>
<span class="comments">;      File format to make. Valid options are 'fits' or 'csv'.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    See the example on pp_editablecube__define.</span>
<span class="comments">; </span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Oct/2009</span>
<span class="comments">;-</span>
<a id="pp_editablecube::write:source"></a>pro pp_editablecube::write,filename
compile_opt idl2

filename=n_elements(filename) eq 1 ? filename : self.newfile
self.newfile=filename
if (self.newfile eq '') then message,'Filename required to write the cube'
print,'Writing cube to file ',filename
openw,unit,self.newfile,/get_lun
<span class="comments">;Write the labels</span>
writeu,unit,strjoin((*self.labels)+string(13B)+string(10B))
<span class="comments">;Pad to the number of label records</span>
<span class="comments">;if (self.llength lt self.info.labelrecords*self.info.recordsize) then $</span>
<span class="comments">; writeu,unit,replicate(string(10B),self.info.labelrecords*self.info.recordsize-self.llength)</span>
point_lun,unit,self.info.recordbytes*self.info.historystart
<span class="comments">;Write the history</span>
writeu,unit,strjoin((*self.history)+string(13B)+string(10B))
<span class="comments">;Pad to the number of history records</span>
point_lun,unit,self.info.recordbytes*self.info.binarystart
<span class="comments">;Write the data</span>
writeu,unit,*self.raw
<span class="comments">;Pad to the number of binary records</span>
point_lun,unit,self.info.recordbytes*self.info.filerecords
free_lun,unit 

end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Exports the cube in the object to a fits or csv file.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    file, in, required</span>
<span class="comments">;      The name of the file to which the cube will be written.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    See the example on pp_editablecube__define.</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Oct/2009</span>
<span class="comments">;-</span>
<a id="pp_editablecube::export:source"></a>pro pp_editablecube::export,file,format=format
compile_opt idl2,logical_predicate

format=n_elements(format) ? format : 'fits'

c=self

templ={}
if c.bands then begin
  bandnames=strtrim(sindgen(c.bands),2)
  ml=max(strlen(bandnames))
  bandnames='BAND_'+string(sindgen(c.bands),format='(I0'+strtrim(ml,2)+')')
  foreach bn,bandnames do templ=create_struct(templ,bn,0d0)
endif else templ={}

foreach bn,c.backnames do templ=create_struct(templ,idl_validname(bn,/convert_all),0d0)

cubestruct=replicate(templ,c.lines*c.samples)
if c.bands then begin
  core=reform(c.core,c.samples*c.lines,c.bands)
  for i=0,c.bands-1 do cubestruct.(i)=core[*,i]
endif
if c.nback then begin
  backplanes=reform(c.backplanes,c.lines*c.samples,c.nback)
  for i=0,c.nback-1 do cubestruct.(i+c.bands)=backplanes[*,i]
endif

if strlowcase(format) eq 'fits' then mwrfits,cubestruct,file,/create
if strlowcase(format) eq 'csv' then write_csv_pp,file,cubestruct,/titles

end

<a id="pp_editablecube::cleanup:source"></a>pro pp_editablecube::cleanup
compile_opt idl2,hidden
ptr_free,self.oldlabels,self.oldhistory
self->pp_readcube::cleanup
end


<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Object to read, edit and write an ISIS cube. Read functionality is the same</span>
<span class="comments">;    as that of the pp_readcube class (it is inherited from it, see its documentation</span>
<span class="comments">;    for details and examples on reading). Once the object is instantiated, either</span>
<span class="comments">;    from a file or from another editable cube, its data and metadata can be</span>
<span class="comments">;    changed, and it can be written to a file.</span>
<span class="comments">;    </span>
<span class="comments">;    Initialization parses the cube into the object, other methods retrieve parts of it,</span>
<span class="comments">;    edit it, or write it to a file.</span>
<span class="comments">;    </span>
<span class="comments">;    On reading, makes the same assumptions (inherits them) from the pp_readcube class:</span>
<span class="comments">;    All suffix items are the same data type as core items, cube has 3 axes in BSQ order,</span>
<span class="comments">;    and records have fixed length. On writing, these assumptions are maintained.</span>
<span class="comments">;    </span>
<span class="comments">;    The only methods intended to be public are: getproperty, getspecialvalues,</span>
<span class="comments">;    getfromheader, getsuffixbyname, getbandbywavelength, setproperty, headeredit, and write.</span>
<span class="comments">;    </span>
<span class="comments">;    See the documentation of the method setproperty for the most useful edit and</span>
<span class="comments">;    write example, or getproperty for the most useful read example.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    For read use, see the example on pp_readcube__define.</span>
<span class="comments">;    </span>
<span class="comments">;    To initialize from the cube CM_1553510065_1_ir.cub::</span>
<span class="comments">; </span>
<span class="comments">;      a=obj_new('pp_editablecube',file='CM_1553510065_1_ir.cub')</span>
<span class="comments">;      </span>
<span class="comments">;    To add a dummy backplane::</span>
<span class="comments">;    </span>
<span class="comments">;      a->getproperty,backplanes=back,backnames=bnames,lines=lines,samples=samples</span>
<span class="comments">;      backplanes=[[[backplanes]],[[findgen(lines,samples)]]]</span>
<span class="comments">;      backnames=[backnames,'DUMMY']</span>
<span class="comments">;      a->setproperty,backplanes=back,backnames=bnames      </span>
<span class="comments">;    </span>
<span class="comments">;    To remove the first core band::</span>
<span class="comments">;    </span>
<span class="comments">;      a->getproperty,core=core,wavelengths=wavs</span>
<span class="comments">;      core=core[*,*,1:*] & wavs=wavs[1:*]</span>
<span class="comments">;      a->setproperty,core=core,wavelengths=wavs</span>
<span class="comments">;      </span>
<span class="comments">;    To add lines to the history part of the header::</span>
<span class="comments">;    </span>
<span class="comments">;      app=['GROUP = testedit','date = '+strcompress(systime(),/remove),'END_GROUP = testdate']  </span>
<span class="comments">;      a->headerset,append=app</span>
<span class="comments">;      </span>
<span class="comments">;    To write the edited cube to 'testedit.cub'::</span>
<span class="comments">;    </span>
<span class="comments">;      a->write,'testedit.cub'</span>
<span class="comments">;</span>
<span class="comments">;    To write the edited cube to 'testedit.fits'::</span>
<span class="comments">;</span>
<span class="comments">;      a->export,'testedit.cub'</span>
<span class="comments">;      </span>
<span class="comments">;    Destroy the object when done with it::</span>
<span class="comments">;    </span>
<span class="comments">;      obj_destroy,a</span>
<span class="comments">;</span>
<span class="comments">; :Uses: pp_getcubeheadervalue, pp_extractfields, pp_setcubeheadervalue </span>
<span class="comments">; </span>
<span class="comments">; :Uses: pp_readcube</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Oct/2009</span>
<span class="comments">;-</span>
<a id="pp_editablecube__define:source"></a>pro pp_editablecube__define
 void={pp_editablecube,inherits pp_readcube,newfile:'',$
  oldlabels:ptr_new(),oldhistory:ptr_new(),$
  llength:0L,oldllength:0L,hlength:0L,oldhlength:0L,$
  binlength:0LL,oldbinlength:0LL,preservespecial:0}
end
</code>
    </div>
  </body>
</html>