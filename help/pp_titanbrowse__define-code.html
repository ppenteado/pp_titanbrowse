<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Wed Jun 22 22:23:08 2016 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>pp_titanbrowse__define.pro (Documentation for pp_lib)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="pp_titanbrowse__define.pro (Documentation for pp_lib)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;+</span>
<span class="comments">; :Uses: pp_editablecube__define, pp_getcubeheadervalue, pp_extractfields, pp_setcubeheadervalue, pp_readcube__define,</span>
<span class="comments">;   pp_cubecollection__define, pp_titanbrowse_metadb__define, pp_titanbrowse_db__define</span>
<span class="comments">; </span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Nov/2009</span>
<span class="comments">; </span>
<span class="comments">; :Version: 20141114</span>
<span class="comments">; </span>
<span class="comments">;-</span>

<a id="pp_titanbrowse::init:source"></a>function pp_titanbrowse::init,mdbfiles,vis=vis,cubestoselect=cubes
compile_opt idl2,logical_predicate
ret=0
self.version='20141114'
<span class="comments">;Defaults</span>
vis=n_elements(vis) eq 1 ? vis : 0
channel=vis ? 'vis' : 'ir'
nfiles=n_elements(mdbfiles)
mdbfiles=nfiles gt 0 ? mdbfiles : file_search('covims_*_'+channel+'.sav',count=nfiles)
if n_elements(cubes) then begin
  ft=file_test('pp_titanbrowse_index.sav')
  if ft then begin
    restore,'pp_titanbrowse_index.sav',/verbose,/relax
    mdbfiles=hash()
    keys=(pp_titanbrowse_cubehash.keys()).toarray()
    foreach cube,cubes do begin
      wcount=1
      key=pp_titanbrowse_cubehash.haskey(cube) ? cube : keys[where(strmatch(keys,'*'+cube+'*'),wcount)]
      if wcount then mdbfiles[(pp_titanbrowse_cubehash[key[0]]).mdbfile]=!null
    endforeach
    <span class="comments">;mdbfiles=(mdbfiles.keys()).sort()</span>
    <span class="comments">;nfiles=mdbfiles.count()</span>
    <span class="comments">;mdbfiles=mdbfiles.toarray()</span>
    mdbfiles=(mdbfiles.keys()).toarray()
    mdbfiles=mdbfiles[sort(mdbfiles)]
    nfiles=n_elements(mdbfiles)
  endif else print,'There is no index file, one will be built'
endif
if (nfiles eq 0) then begin
  print,'pp_titanbrowse: No metadata files found or provided'
  return,0
endif 

<span class="comments">;Initialize the database objects</span>
podb=objarr(nfiles)
for i=0,nfiles-1 do begin
  print,'Reading from file "',mdbfiles[i],'" ('+strcompress(string(i+1,'/',nfiles),/rem)+')'
  podb[i]=obj_new('pp_titanbrowse_db',mdbfiles[i])
  if (~obj_valid(podb[i])) then begin <span class="comments">;Get out if one of the objects failed to initialize</span>
    print,'pp_titanbrowse: Could not initialize database from "',mdbfiles[i],'"'
    ret=0
  endif else begin <span class="comments">;Test that all objects have the same type of data (same self.std)</span>
    podb[i]->getproperty,std=std
    if (i eq 0) then begin
      ostd=std
      ret=1
    endif else begin
      tmp=(std.bands eq ostd.bands)&&(std.nback eq ostd.nback)&&(std.unit eq ostd.unit)
      tmp=tmp&&(std.type eq ostd.type)
      tmp=tmp&&(finite(*std.fill) ? *std.fill eq *ostd.fill : finite(*std.fill,/sign) eq finite(*ostd.fill,/sign))
      tmp=tmp&&array_equal(*std.bnames,*ostd.bnames)
      tmp=tmp&&array_equal(*std.tnames,*ostd.tnames)&&array_equal(*std.bunits,*ostd.bunits)
      if (~array_equal(*std.wavs,*ostd.wavs)) then begin <span class="comments">;Ignore differences due to the fix of the 5.108/5.1225 wavelength</span>
        w=where(*std.wavs ne *ostd.wavs,nw)
        for j=0,nw-1 do begin
          wvs=[(*std.wavs)[w[j]],(*ostd.wavs)[w[j]]]
          tmp=tmp&&(strupcase(std.unit) eq 'MICROMETER')&&(max(wvs) eq 5.1225d0)&&(min(wvs) eq 5.108d0)
          if (tmp) then print,'pp_titanbrowse: Ignoring difference between 5.108 and 5.1225 '+string(181B)+'m'
        endfor
      endif
      if (~tmp) then begin  
        print,'pp_titanbrowse: Database in "',mdbfiles[i],'" is incompatible with that of the previous files'
        ret=0 
      endif else ret=1
    endelse
  endelse  
  if (ret eq 0) then begin <span class="comments">;Get out if something did not work</span>
    obj_destroy,podb
    return,ret  
  endif
endfor
<span class="comments">;Allocate the pointer arrays to the core and backplane vectors</span>
self.dbvecs.core=ptr_new(ptrarr(std.bands,nfiles),/no_copy)
self.dbvecs.back=ptr_new(ptrarr(std.nback,nfiles),/no_copy)
<span class="comments">;Trackers of current selection</span>
self.nselcubes=ptr_new(lonarr(nfiles),/no_copy)
self.nselpixels=ptr_new(lonarr(nfiles),/no_copy)
self.selcubes=ptr_new(ptrarr(nfiles),/no_copy)
self.selpixels=ptr_new(ptrarr(nfiles),/no_copy)
self.selpixels_c=ptr_new(ptrarr(nfiles),/no_copy)
self.selpixels_xz=ptr_new(ptrarr(nfiles),/no_copy)
<span class="comments">;Save things to self</span>
self.podb=ptr_new(podb,/no_copy)
self.nfiles=nfiles
self.mdbfiles=ptr_new(mdbfiles,/no_copy)
self.std=ptr_new(ostd,/no_copy)
self.backindex=hash(*std.bnames,indgen(n_elements(*std.bnames)))

<span class="comments">;Define type for cube information</span>
cmd=*((*self.podb)[0]->getcmd())
tnames=tag_names(cmd.back_max) & nback=n_elements(tnames)
btmp=create_struct(tnames[0],0d0)
for i=1,nback-2 do btmp=create_struct(btmp,tnames[i],0d0)
btmp=create_struct(name='pp_titanbrowse_cmd_back',btmp,tnames[nback-1],0d0)
cmd={pp_titanbrowse_cmd,rev:'',seq:'',seq_title:'',$
 prod_id:'',start:'',stop:'',nat_start:'',$
 lines:0L,samples:0L,pixels:0L,surf_pixels:0L,$
 exposure:0d0,ir_mode:'',vis_mode:'',file:'',$
 back_max:btmp,back_min:btmp}
cubeinfo={pp_titanbrowse_cubeinfo,inherits pp_titanbrowse_cmd,dbfile:'',cubefile:'',dbind:0L,cubeind:0L}
<span class="comments">;Define type for pixel data</span>
pixdata={pp_titanbrowse_pixdata,core:dblarr((*self.std).bands),backplanes:btmp,cube:'',x:0L,z:0L}

if n_elements(cubes) && (~ft) then begin
  self.indexcubes
  print,'Saving cube index to file pp_titanbrowse_index.sav'
  self.saveindex
endif
return,ret
end

<a id="pp_titanbrowse::indexcubes:source"></a>pro pp_titanbrowse::indexcubes
compile_opt idl2,logical_predicate
  self.cubehash=hash()
  mdbfiles=*self.mdbfiles
  for i=0,self.nfiles-1 do begin
    files=(*self.podb)[i]->filenames(ncubes=ncubes)
    (*self.podb)[i]->getproperty,pstart=pstart
    ps=*pstart
    foreach file,files,ifile do begin
      tmp={pp_titanbrowse_cubemd}
      tmp.dbindex=i
      tmp.pstart=ps[ifile]
      tmp.mdbfile=mdbfiles[i]
      (self.cubehash)[file]=tmp
    endforeach
  endfor
end

<a id="pp_titanbrowse::saveindex:source"></a>pro pp_titanbrowse::saveindex,file
compile_opt idl2,logical_predicate
file=n_elements(file) ? file : 'pp_titanbrowse_index.sav'
if ~obj_valid(self.cubehash) then self.indexcubes
pp_titanbrowse_cubehash=self.cubehash
save,file=file,pp_titanbrowse_cubehash
end

<a id="pp_titanbrowse::selectcubes:source"></a>pro pp_titanbrowse::selectcubes,iexpr,all=all,none=none,count=count,pixelsselected=pixsel,bytable=table,wholecubes=wholecubes
<span class="comments">;Changes the current cube selection, to all cubes or no cubes, or filter the selection with the given expression.</span>
<span class="comments">;iexpr must already be in the internal format (expressions built with aliases must be parsed to make them valid here).</span>
compile_opt idl2

bytable=n_elements(table)
if bytable gt 0 then begin
  l=pp_locate(table.cubefile)
  cube_names=(l.keys()).toarray()
  ci=self.getcubeinfo(cube_name=cube_names)
  dl=pp_locate(ci.dbind)
  self.selectcubes,/none
  pstart=hash()
  foreach dbi,dl,idbi do begin
    (*self.nselcubes)[idbi]=n_elements(dbi)
    (*self.selcubes)[idbi]=ptr_new(ci[dbi].cubeind)
    s=sort(ci[dbi].cubeind)
    citmp=(ci[dbi])[s]
    tmp=total(citmp.pixels,/cumulative,/integer)-citmp[0].pixels
    tmp2=hash()
    foreach cube,citmp,icube do tmp2[cube.cubeind]=tmp[icube]
    pstart[idbi]=tmp2 
  endforeach
  self.selectpixels,/none
  if keyword_set(wholecubes) then begin
    self.selectpixels,/all
    return
  endif
  dbselpixs=hash(dl.keys())
  foreach cube,cube_names,icube do begin
    pixels=table[l[cube]]
    pixinds=pixels.x+ci[icube].samples*pixels.z
    <span class="comments">;(*self.podb)[ci[icube].dbind]->getproperty,pstart=pstart</span>
    <span class="comments">;pixstosel=(*pstart)[ci[icube].cubeind]+pixinds</span>
    pixstosel=(pstart[ci[icube].dbind])[ci[icube].cubeind]+pixinds
    dbselpixs[ci[icube].dbind]=[dbselpixs[ci[icube].dbind],pixstosel]
  endforeach
  whereres=hash()
  foreach dbselpix,dbselpixs,idbsel do begin
    pixtosel=dbselpix[sort(dbselpix)]
    whereres[idbsel]=pixtosel
  endforeach
  self.selectpixels,/all
  self.selectpixels,whereres=whereres
endif

if keyword_set(none) then begin <span class="comments">;If selection is to be cleared</span>
  (*self.nselcubes)[*]=0L
  ptr_free,(*self.selcubes)
endif else if keyword_set(all) then begin <span class="comments">;If selecting everything</span>
  for i=0,self.nfiles-1 do begin
    void=(*self.podb)[i]->filenames(ncubes=ncubes)
    (*self.nselcubes)[i]=ncubes
    ptr_free,(*self.selcubes)[i]
    (*self.selcubes)[i]=ptr_new(lindgen(ncubes))
  endfor
endif else if keyword_set(pixsel) then begin <span class="comments">;If selecting only the cubes with selected pixels</span>
  for i=0,self.nfiles-1 do if ((*self.nselcubes)[i] gt 0) then begin
    ptr_free,(*self.selcubes)[i]
    (*self.nselcubes)[i]=0
    if (ptr_valid((*self.selpixels_c)[i])) then begin
      pixcube=*((*self.selpixels_c)[i])
      s=sort(pixcube) & pixcube=pixcube[s] & pixcube=pixcube[uniq(pixcube)]
      (*self.nselcubes)[i]=n_elements(pixcube)
      (*self.selcubes)[i]=ptr_new(pixcube,/no_copy)
    endif else (*self.nselcubes)[i]=0L
  endif
endif else if (n_elements(iexpr) eq 1) then begin <span class="comments">;If filtering from given expression</span>
  expr=strtrim(iexpr,2)
  for i=0,self.nfiles-1 do begin
    catch,error_status
    if (error_status ne 0) then begin
      catch,/cancel
      print,'pp_titanbrowse::selectcubes: Expression evaluation error'
      break
    endif else if ((*self.nselcubes)[i] gt 0) then begin <span class="comments">;Skip filtering if there are already none selected</span>
<span class="comments">;Make sel and cmd to be used in expr</span>
      sel=*((*self.selcubes)[i])
      pcmd=(*self.podb)[i]->getcmd()
<span class="comments">;      cmd=temporary(*pcmd) ;Borrow instead of copy it, for efficiency</span>
      cmd=(*pcmd)
      tmp=execute('nsel='+expr)
<span class="comments">;Put cmd's contents back</span>
<span class="comments">;      *pcmd=temporary(cmd)</span>
<span class="comments">;Make the new selection</span>
      if tmp then w=where(nsel[sel],count,/l64) else begin
        print,'pp_titanbrowse::selectcubes: Expression evaluation error'
        break
      endelse
      (*self.nselcubes)[i]=count
      ptr_free,(*self.selcubes)[i]
      if (count gt 0) then (*self.selcubes)[i]=ptr_new(sel[w])
    endif
  endfor
endif
count=total(*self.nselcubes,/integer)
<span class="comments">;Clear pixel selections</span>
if ~bytable then self->selectpixels,/none
end

<a id="pp_titanbrowse::selectpixels:source"></a>pro pp_titanbrowse::selectpixels,iexpr,all=all,none=none,count=count,eval=eval,whereres=whereres
<span class="comments">;Changes the current pixel selection, to all pixels or no pixels, or filter the selection with the given expression.</span>
<span class="comments">;iexpr must already be in the internal format (expressions built with aliases must be parsed to make them valid here).</span>
compile_opt idl2
eval=keyword_set(eval)
if keyword_set(none) then begin <span class="comments">;If selection is to be cleared</span>
  (*self.nselpixels)[*]=0L
  ptr_free,(*self.selpixels),(*self.selpixels_c),(*self.selpixels_xz)
endif else if keyword_set(all) then begin <span class="comments">;If selecting everything</span>
  for i=0,self.nfiles-1 do if ((*self.nselcubes)[i] gt 0) then begin <span class="comments">;Skip files with no cubes selected</span>
    sel=*((*self.selcubes)[i]) <span class="comments">;Indexes of selected cubes</span>
<span class="comments">;Get the needed metadata</span>
    pcmd=(*self.podb)[i]->getcmd()
    pixels=(*pcmd).pixels
    npix=total(pixels[sel],/integer)
    selpixels=lonarr(npix)
    pixcube=lonarr(npix)
    pixxz=lonarr(2,npix)
<span class="comments">;    tmp=long(total((*pcmd).pixels[sel],/cumul))-(*pcmd).pixels[sel] ;List start index for each cube's pixels</span>
    <span class="comments">;tmp=(total(pixels,/cumul,/integer)-pixels)[sel] ;List start index for each cube's pixels</span>
<span class="comments">;Get the start location of each cube in the database vectors</span>
     (*self.podb)[i]->getproperty,pstart=pstart
<span class="comments">;Compute the proper indexes from each selected cube (counted relative to all pixels in the file, not just those that are selected)</span>
    k=0
    for j=0,(*self.nselcubes)[i]-1 do begin
      dims=[(*pcmd).samples[sel[j]],(*pcmd).lines[sel[j]]]
      <span class="comments">;pixcube[tmp[j]]=replicate(sel[j],(*pcmd).pixels[sel[j]])</span>
      pixcube[k]=replicate(sel[j],pixels[sel[j]])
      <span class="comments">;tmp2=lindgen((*pcmd).pixels[sel[j]])</span>
      tmp2=lindgen(pixels[sel[j]])
      <span class="comments">;selpixels[tmp[j]]=tmp2+(*pstart)[sel[j]]</span>
      selpixels[k]=tmp2+(*pstart)[sel[j]]
      <span class="comments">;pixxz[tmp[j]*2]=reform(array_indices(dims,tmp2,/dim),2*(*pcmcube_namesd).pixels[sel[j]])</span>
      pixxz[k*2]=reform(array_indices(dims,tmp2,/dim),2*pixels[sel[j]])
      k+=pixels[sel[j]]
    endfor
<span class="comments">;Save things into self</span>
    ptr_free,(*self.selpixels)[i]
    (*self.nselpixels)[i]=npix
    (*self.selpixels)[i]=ptr_new(selpixels,/no_copy)
    ptr_free,(*self.selpixels_c)[i]
    (*self.selpixels_c)[i]=ptr_new(pixcube,/no_copy)
    ptr_free,(*self.selpixels_xz)[i]
    (*self.selpixels_xz)[i]=ptr_new(pixxz,/no_copy)
  endif
endif else if ((n_elements(iexpr) eq 1) or n_elements(whereres) gt 0) then begin <span class="comments">;If filtering from given expression</span>
  if (n_elements(iexpr) eq 1) then expr=strtrim(iexpr,2)
  for i=0,self.nfiles-1 do if ((*self.nselpixels)[i] gt 0) then begin <span class="comments">;Skip files with no pixels selected</span>
<span class="comments">;Make sel and to be used in expr</span>
    sel=*((*self.selpixels)[i]) <span class="comments">;Indexes of selected pixels</span>
    if (n_elements(whereres) gt 0) then begin
      w=whereres[i]
      count=long(n_elements(w))
    endif else begin
      tmp=execute('nsel='+expr)
<span class="comments">;Make the new selection</span>
      if tmp then w=where(nsel,count,/l64) else begin
        print,'pp_titanbrowse::selectpixels: Expression evaluation error'
        break
      endelse
    endelse
    (*self.nselpixels)[i]=count
    ptr_free,(*self.selpixels)[i]
    if (count gt 0) then begin
      (*self.selpixels)[i]=ptr_new(sel[w])
      *((*self.selpixels_c)[i])=(*((*self.selpixels_c)[i]))[w]
      *((*self.selpixels_xz)[i])=(*((*self.selpixels_xz)[i]))[*,w]
    endif else ptr_free,(*self.selpixels_c)[i],(*self.selpixels_xz)[i]
  endif
endif
count=long(total(*self.nselpixels))
<span class="comments">;Set update flag</span>
self.update=1B
end

<a id="pp_titanbrowse::evalexpr:source"></a>function pp_titanbrowse::evalexpr,iexpr,store=store,cube=cube
compile_opt idl2,logical_predicate
cube=keyword_set(cube)
expr=strtrim(iexpr,2)
if (~cube) then begin
  pd={pp_titanbrowse_pixdata}
  self.getproperty,nselpixels=nsp
  res=replicate({pp_titanbrowse_eval,val:!values.d_nan,pixdata:pd},nsp)
  icount=0LL
  sp=self.getselectedpixels()
  res.pixdata=sp
  for i=0,self.nfiles-1 do if ((*self.nselpixels)[i] gt 0) then begin <span class="comments">;Skip files with no pixels selected</span>
    <span class="comments">;Make sel and to be used in expr</span>
    sel=*((*self.selpixels)[i]) <span class="comments">;Indexes of selected pixels</span>
    tmp=execute('nsel='+expr)
    if tmp then w=where(nsel,count,/l64) else begin
      print,'pp_titanbrowse::selectpixels: Expression evaluation error'
      break
    endelse  
  <span class="comments">;  (*self.nselpixels)[i]=count</span>
  <span class="comments">;  ptr_free,(*self.selpixels)[i]</span>
    if (count gt 0) then begin
      nc=(*self.nselpixels)[i]
      res[icount:icount+nc-1].val=nsel
  <span class="comments">;    (*self.selpixels)[i]=ptr_new(sel[w])</span>
  <span class="comments">;    *((*self.selpixels_c)[i])=(*((*self.selpixels_c)[i]))[w]</span>
  <span class="comments">;    *((*self.selpixels_xz)[i])=(*((*self.selpixels_xz)[i]))[*,w]</span>
    endif
      icount+=nc
  endif
  if keyword_set(store) then self.evalres=ptr_new(res)
endif else begin
  ret=list()
  for i=0,self.nfiles-1 do begin
    catch,error_status
    if (error_status ne 0) then begin
      catch,/cancel
      print,'pp_titanbrowse::selectcubes: Expression evaluation error'
      break
    endif else if ((*self.nselcubes)[i] gt 0) then begin <span class="comments">;Skip filtering if there are already none selected</span>
      <span class="comments">;Make sel and cmd to be used in expr</span>
      sel=*((*self.selcubes)[i])
      pcmd=(*self.podb)[i]->getcmd()
      <span class="comments">;      cmd=temporary(*pcmd) ;Borrow instead of copy it, for efficiency</span>
      cmd=(*pcmd)
      tmp=execute('nsel='+expr)
      <span class="comments">;Put cmd's contents back</span>
      <span class="comments">;      *pcmd=temporary(cmd)</span>
      <span class="comments">;Make the new selection</span>
      if tmp then w=where(nsel[sel],count,/l64) else begin
        print,'pp_titanbrowse::selectcubes: Expression evaluation error'
        break
      endelse
      if (count gt 0) then begin
        nc=(*self.nselcubes)[i]
        ret.add,nsel[sel],/extract
        <span class="comments">;    (*self.selpixels)[i]=ptr_new(sel[w])</span>
        <span class="comments">;    *((*self.selpixels_c)[i])=(*((*self.selpixels_c)[i]))[w]</span>
        <span class="comments">;    *((*self.selpixels_xz)[i])=(*((*self.selpixels_xz)[i]))[*,w]</span>
      endif      
<span class="comments">;      (*self.nselcubes)[i]=count</span>
<span class="comments">;      ptr_free,(*self.selcubes)[i]</span>
<span class="comments">;      if (count gt 0) then (*self.selcubes)[i]=ptr_new(sel[w])</span>
    endif
  endfor
  res=reform(ret.toarray())
  if keyword_set(store) then self.cubeevalres=ptr_new(res)
endelse
return,res

end

<a id="pp_titanbrowse::parseexpr:source"></a>function pp_titanbrowse::parseexpr,iexpr,cubes=cubes,pixels=pixels
<span class="comments">;Converts the occurences of pseudovariables in expr into the proper</span>
<span class="comments">;internal variable references. If cubes is not set, conversion is for</span>
<span class="comments">;pixel variable names, in which case the needed heap variables are loaded.</span>
<span class="comments">;Backplane names are like '_b_latitude_', and core band names are like '_c_71_'</span>
compile_opt idl2

<span class="comments">;Defaults</span>
cubes=keyword_set(cubes) ? 1B : keyword_set(pixels) ? 0B : 1B
pixels=~cubes
ret=iexpr
if cubes then return,ret <span class="comments">;Parse cube pseudovariables</span>
<span class="comments">;Parse pixel pseudovariables</span>
ret=iexpr
<span class="comments">;Parse backplane pseudovariables</span>
binds=hash()
while stregex(ret,'_b_([[:alnum:]_]+)_',/boolean) do begin
  smp=stregex(ret,'_b_([[:alnum:]_]+)_',/subexpr,length=sml)
  strbegin=strmid(ret,0,smp[0])
  strend=strmid(ret,smp[0]+sml[0])
  bind=(self.backindex)[strupcase(strmid(ret,smp[1],sml[1]))]
  binds[bind]=!null
  ret=strbegin+'((*((*self.podb)[i]->getbackplane('+strtrim(bind,2)+',/po)))[sel])'+strend
endwhile
binds=(binds.keys()).toarray()
if (binds ne !null) then binds=binds[sort(binds)]
<span class="comments">;Parse core pseudovariables</span>
cinds=hash()
while stregex(ret,'_c_([[:digit:]]+)_',/boolean) do begin
  smp=stregex(ret,'_c_([[:digit:]]+)_',/subexpr,length=sml)
  strbegin=strmid(ret,0,smp[0])
  strend=strmid(ret,smp[0]+sml[0])
  cind=fix(strmid(ret,smp[1],sml[1]))
  cinds[cind]=!null
  ret=strbegin+'((*((*self.podb)[i]->getband('+strtrim(cind,2)+',/po)))[sel])'+strend
endwhile
cinds=(cinds.keys()).toarray()
if (cinds ne !null) then cinds=cinds[sort(cinds)]


<span class="comments">;;old parser, needed the variables to be separated by whitespace</span>
<span class="comments">;;split tokens by whitespace  </span>
<span class="comments">;tmp=strsplit(strtrim(iexpr,2),/extract,count=nt)</span>
<span class="comments">;;Parse backplane pseudovariables</span>
<span class="comments">;wb=where((strpos(tmp,'_b_') eq 0) and (strpos(tmp,'_',/reverse_search) eq (strlen(tmp)-1)),nwb)</span>
<span class="comments">;if (nwb gt 0) then begin</span>
<span class="comments">;  namesb=strmid(tmp[wb],3)</span>
<span class="comments">;  binds=intarr(nwb)</span>
<span class="comments">;  (*self.podb)[0]->getproperty,std=std</span>
<span class="comments">;  for i=0,nwb-1 do begin</span>
<span class="comments">;    namesb[i]=strupcase(strmid(namesb[i],0,strlen(namesb[i])-1))</span>
<span class="comments">;    binds[i]=(where(strpos(*std.bnames,namesb[i]) ne -1))[0]</span>
<span class="comments">;  endfor</span>
<span class="comments">;  btoks='(*((*self.podb)[i]->getbackplane('+strtrim(string(binds),2)+',/po)))[sel]'</span>
<span class="comments">;  ;btoks='(*((*self.podb)[i]->getbackplane('+strtrim(string(binds),2)+',/po)))'</span>
<span class="comments">;  tmp[wb]=btoks</span>
<span class="comments">;  binds=binds[sort(binds)]</span>
<span class="comments">;  binds=binds[uniq(binds)]</span>
<span class="comments">;endif</span>
<span class="comments">;;Parse core pseudovariables</span>
<span class="comments">;wc=where((strpos(tmp,'_c_') eq 0) and (strpos(tmp,'_',/reverse_search) eq (strlen(tmp)-1)),nwc)</span>
<span class="comments">;if (nwc gt 0) then begin</span>
<span class="comments">;  ctoks=strarr(nwc)</span>
<span class="comments">;  namesc=strmid(tmp[wc],3)</span>
<span class="comments">;  for i=0,nwc-1 do namesc[i]=strmid(namesc[i],0,strlen(namesc[i])-1)</span>
<span class="comments">;  cinds=fix(namesc)</span>
<span class="comments">;  ctoks='(*((*self.podb)[i]->getband('+namesc+',/po)))[sel]'</span>
<span class="comments">;  ;ctoks='(*((*self.podb)[i]->getband('+namesc+',/po)))'</span>
<span class="comments">;  tmp[wc]=ctoks</span>
<span class="comments">;  cinds=cinds[sort(cinds)]</span>
<span class="comments">;  cinds=cinds[uniq(cinds)]</span>
<span class="comments">;endif</span>
<span class="comments">;;Assemble the output from the pieces</span>
<span class="comments">;ret=strjoin(tmp,' ')</span>

<span class="comments">;Load the needed backplanes and core bands</span>
for i=0,self.nfiles-1 do if ((*self.nselpixels)[i] gt 0) then begin
  (*self.podb)[i]->opendbsav
  for j=0,n_elements(cinds)-1 do (*self.podb)[i]->loadband,cinds[j]
  for j=0,n_elements(binds)-1 do (*self.podb)[i]->loadbackplane,binds[j]
  (*self.podb)[i]->opendbsav,/close
endif



return,ret
end

<a id="pp_titanbrowse::cleardbvecs:source"></a>pro pp_titanbrowse::cleardbvecs
<span class="comments">;Unloads all core and backplane vectors currently loaded.</span>
compile_opt idl2
for i=0,nfiles-1 do (*self.podb)[i]->unload
end

<a id="pp_titanbrowse::getproperty:source"></a>pro pp_titanbrowse::getproperty,cubelist=cubelist,pixellist=pixellist,update=update,$
 mdbfiles=mdbfiles,odb=odb,std=std,nselcubes=nselcubes,nselpixels=nselpixels,version=version,$
 used_memory=used_memory,evalres=evalres,cubeevalres=cubeevalres,cubehash=cubehash
compile_opt idl2

if arg_present(cubelist) then begin
  ncubs=long(total(*self.nselcubes))
  if (ncubs gt 0) then begin
    cubelist=strarr(1L+ncubs)
    tmp=long(total(*self.nselcubes,/cumul))-*self.nselcubes
    finds=replicate(-1L,ncubs)
    cinds=replicate(-1L,ncubs)
    for i=0L,self.nfiles-1 do if ((*self.nselcubes)[i] gt 0) then begin
      finds[tmp[i]]=replicate(i,(*self.nselcubes)[i])
      cinds[tmp[i]]=*(*self.selcubes)[i]
<span class="comments">;      cubelist[tmp[i]]=((*self.podb)[i]->filenames())[*(*self.selcubes)[i]]</span>
    endif
    ci=self->getcubeinfo(file_index=finds,cube_index=cinds)
    lines=string(ci.lines) & samples=string(ci.samples) & pixels=string(ci.pixels) & surf_pixels=string(ci.surf_pixels)
    exposure=string(ci.exposure) & dbind=string(ci.dbind) & cubeind=string(ci.cubeind)
    seq_title=ci.seq_title
    w=where(strlen(seq_title) lt 25,nw)
    if (nw gt 0) then seq_title[w]=string(seq_title[w],format='(A-25)')
    tmp=[[ci.cubefile],[ci.rev],[ci.seq],[seq_title],[ci.prod_id],[ci.start],[ci.stop],[ci.nat_start],$
    [lines],[samples],[pixels],[surf_pixels],[exposure],[ci.ir_mode],[ci.vis_mode],[ci.dbfile],$
    [dbind],[cubeind]]
    cubelist[1]=strjoin(transpose(tmp),string(9B))
    pos=strsplit(cubelist[1],count=npos)
    tmp=string(' ',format='(A'+string(strlen(cubelist[1]))+')')
    names=tag_names(ci[0]) & names=[names[17],names[0:13],names[[16,18,19]]]
    for i=0,npos-1 do strput,tmp,names[i]+string(9B),pos[i]
    cubelist[0]=tmp
  endif else cubelist=''
endif

if (arg_present(pixellist)) then begin
  npix=long(total(*self.nselpixels))
  if (npix gt 0) then begin
    pixellist=strarr(1L+npix)
<span class="comments">;    tmp=long(total(*self.nselpixels,/cumul))-*self.nselpixels</span>
<span class="comments">;    for i=0,self.nfiles-1 do if ((*self.nselpixels)[i] gt 0) then begin</span>
<span class="comments">;      tmp2=strjoin(string(*(*self.selpixels_xz)[i]))</span>
<span class="comments">;      pixellist[tmp[i]]=((*self.podb)[i]->filenames())[*(*self.selpixels_c)[i]]+' '+tmp2</span>
<span class="comments">;    endif</span>
    pix=self->getselectedpixels()
    tmp=[[pix.cube],[string(pix.x)],[string(pix.z)],[string(pix.backplanes.lat_0)],[string(pix.backplanes.lon_0)]]
    pixellist[1]=strjoin(transpose(tmp),string(9B))
    pos=strsplit(pixellist[1],count=npos)
    tmp=string(' ',format='(A'+string(strlen(pixellist[1]))+')')
    names=['CUBE','X','Z','LAT_0','LON_0']
    for i=0,npos-1 do strput,tmp,names[i]+string(9B),pos[i]
    pixellist[0]=tmp
  endif else pixellist=''
endif

if (arg_present(update)) then update=self.update

if (arg_present(mdbfiles)) then mdbfiles=*self.mdbfiles

if (arg_present(odb)) then odb=*self.podb

if (arg_present(std)) then std=self.std

if (arg_present(nselcubes)) then nselcubes=long(total(*self.nselcubes))

if (arg_present(nselpixels)) then nselpixels=long(total(*self.nselpixels))

if (arg_present(version)) then version=self.version

if (arg_present(cubehash)) then cubehash=self.cubehash

if (arg_present(used_memory)) then begin
  used_memory=0ULL
  for i=0,self.nfiles-1 do begin
    ((*self.podb)[i]).getproperty,used_memory=um
    used_memory+=um
  endfor
endif

if arg_present(evalres) then evalres=self.evalres ? *self.evalres : !null
if arg_present(cubeevalres) then cubeevalres=self.cubeevalres ? *self.cubeevalres : !null

end

<a id="pp_titanbrowse::getselectedpixels:source"></a>function pp_titanbrowse::getselectedpixels
compile_opt idl2
ret=-1
nsel=long(total(*self.nselpixels))
if (nsel gt 0L) then begin
  ret=replicate({pp_titanbrowse_pixdata},nsel)
  tn=tag_names(ret[0].backplanes)
  nt=n_elements(tn)
  k=0L
  for i=0,self.nfiles-1 do if ((*self.nselpixels)[i] gt 0) then begin
    cubes=*((*self.selpixels_c)[i]) <span class="comments">;indexes of tue cubes of the selected pixels</span>
    pixxz=*((*self.selpixels_xz)[i]) <span class="comments">;x and z indexes of the selected pixels</span>
    for j=0,n_elements(cubes)-1 do begin
      if ((j eq 0) || cubes[j] ne cubes[j-1]) then begin <span class="comments">;Get cube data if necessary</span>
        cube=(*self.podb)[i]->getcube(cubes[j])
        cube->getproperty,core=core,backplanes=backplanes,file=file
      endif
      ret[k].core=core[pixxz[0,j],pixxz[1,j],*]
      ret[k].x=pixxz[0,j] & ret[k].z=pixxz[1,j]
      ret[k].cube=file
      for l=0,nt-1 do ret[k].backplanes.(l)=backplanes[pixxz[0,j],pixxz[1,j],l]
      k++
    endfor
  endif
endif
return,ret
end

<a id="pp_titanbrowse::getselectedcubes:source"></a>function pp_titanbrowse::getselectedcubes
compile_opt idl2
ret=-1
nsel=long(total(*self.nselcubes))
if (nsel gt 0L) then begin
  ret=objarr(nsel)
  k=0L
  for i=0,self.nfiles-1 do if ((*self.nselcubes)[i] gt 0) then begin
    ret[k]=(*self.podb)[i]->getcube(*((*self.selcubes)[i]))
    k+=(*self.nselcubes)[i]
  endif
endif
return,ret
end

<a id="pp_titanbrowse::setproperty:source"></a>pro pp_titanbrowse::setproperty,update=update
compile_opt idl2
if (n_elements(update) eq 1) then self.update=update
end

<a id="pp_titanbrowse::getcubeinfo:source"></a>function pp_titanbrowse::getcubeinfo,file_index=finds,cube_index=cinds,cube_name=cnames,cube_object=cobj
<span class="comments">;Retrieve metadata for the cubes selected, by their names, or by db file and cube indexes</span>
compile_opt idl2
ret=-1
nc=n_elements(cnames)
if (nc gt 0) then begin <span class="comments">;Selection by cube name (just prepare finds and cinds)</span>
  finds=lonarr(nc) & cinds=lonarr(nc) &found=bytarr(nc)
  for i=0,self.nfiles-1 do if (total(found) lt nc) then begin
    names=(*self.podb)[i]->filenames()
    wtmp=where(~found,nwtmp)
    for j=0,nwtmp-1 do begin
      k=wtmp[j]
      w=where(strmatch(names,cnames[k]),nw)
      if nw gt 0 then begin & finds[k]=i & cinds[k]=w & found[k]=1 & endif
    endfor
  endif
  if (total(found) lt nc) then message,'Cube(s) not found: '+cnames[where(~found)]
endif
nf=n_elements(finds) & nc=n_elements(cinds)
if (nf gt 0)&&(nc gt 0)&&(nf eq nc) then begin <span class="comments">;Selection by file and cube indexes</span>
  if arg_present(cobj) then cobj=objarr(nf) 
  ret=replicate({pp_titanbrowse_cubeinfo},nf)
  ret[*].dbfile=(*self.mdbfiles)[finds]
  ret[*].dbind=finds
  ret[*].cubeind=cinds
  for i=0,nf-1 do begin
    if ((i eq 0) || (finds[i] ne finds[i-1])) then begin
      cmd=*((*self.podb)[finds[i]]->getcmd())
      names=(*self.podb)[finds[i]]->filenames()
    endif
    cind=cinds[i]
    if arg_present(cobj) then cobj[i]=*((*self.podb)[finds[i]])->getcube(cind)
    ret[i].cubefile=names[cind]
<span class="comments">;Convert the elements from the cmd fields into the fields of ret</span>
<span class="comments">;Only works this because both were defined with matching fields</span>
    for j=0,n_tags(cmd)-3 do ret[i].(j)=cmd.(j)[cind]
    for j=0,n_tags(cmd.back_max)-1 do begin
      ret[i].back_max.(j)=cmd.back_max.(j)[cind]
      ret[i].back_min.(j)=cmd.back_min.(j)[cind]
    endfor
  endfor
endif else message,'Invalid selection specification'
return,ret
end

<a id="pp_titanbrowse::getpixeldata:source"></a>function pp_titanbrowse::getpixeldata,pixin
compile_opt idl2,logical_predicate

np=n_elements(pixin)
if ~np then return,!null

ret=replicate({pp_titanbrowse_pixdata},np)
l=pp_locate(pixin.cubefile)
cube_names=(l.keys()).toarray()
ci=self.getcubeinfo(cube_name=cube_names)

foreach cube,cube_names,icube do begin
  self.selectcubes,/all
  self.selectcubes,"cmd.file eq '"+cube+"'",count=count
  self.selectpixels,/all,count=count
  inds=pixin.x+pixin.y*ci[icube].samples
  print,count
endforeach

return,ret

end

<a id="pp_titanbrowse::_overloadBracketsRightSide:source"></a>function pp_titanbrowse::_overloadBracketsRightSide, isRange, sub1, $
  sub2, sub3, sub4, sub5, sub6, sub7, sub8
compile_opt idl2,logical_predicate
if isRange then return,!null
ret=list()
foreach cube,sub1 do begin
  self.selectcubes,/all
  self.selectcubes,'strmatch(cmd.file,"*'+cube+'*")'
  ret.add,reform(self.getselectedcubes()),/extract
endforeach
return,ret.toarray()
end

<a id="pp_titanbrowse::cleanup:source"></a>pro pp_titanbrowse::cleanup
compile_opt idl2,hidden
ptr_free,self.mdbfiles,self.std,self.nselcubes,self.nselpixels
ptr_free,*self.selcubes,*self.selpixels,self.selcubes,self.selpixels_c,self.selpixels,self.selpixels_xz
ptr_free,*self.dbvecs.core,*self.dbvecs.back,self.dbvecs.core,self.dbvecs.back
if (self.nfiles gt 0) then begin
  obj_destroy,(*self.podb)
  ptr_free,self.podb
endif
end

<a id="pp_titanbrowse__define:source"></a>pro pp_titanbrowse__define
<span class="comments">;Object implementing the new titanbrowse, both the procedural API and GUI.</span>
<span class="comments">;Initialized from pp_titanbrowse_metadb savefiles.</span>
compile_opt idl2
void={pp_titanbrowse_cubemd,dbindex:0L,pstart:0L,npixels:0L,lines:0L,samples:0L,mdbfile:''}
void={pp_titanbrowse,version:'',nfiles:0,mdbfiles:ptr_new(),podb:ptr_new(),std:ptr_new(),$
 dbvecs:{pp_titanbrowse_dbvecs,core:ptr_new(),back:ptr_new()},$
 nselcubes:ptr_new(),nselpixels:ptr_new(),selcubes:ptr_new(),selpixels:ptr_new(),$
 selpixels_c:ptr_new(),selpixels_xz:ptr_new(),update:0B,$
 backindex:obj_new(),inherits IDL_Object,evalres:ptr_new(),cubeevalres:ptr_new(),$
 cubehash:obj_new()}
end
</code>
    </div>
  </body>
</html>