<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Wed Jun 22 22:23:07 2016 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>pp_readcube__define.pro (Documentation for pp_lib)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="pp_readcube__define.pro (Documentation for pp_lib)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;+</span>
<span class="comments">;</span>
<span class="comments">; :Uses: pp_getcubeheadervalue, pp_extractfields, pp_buffered_vector</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Oct/2009</span>
<span class="comments">;-</span>

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Provided with the name of the file, initializes the object reading the cube in it. </span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    file : in, required</span>
<span class="comments">;      The name of the file that contains the cube.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    special : in, optional, default=0</span>
<span class="comments">;      Determines the type of special value replacement to use:</span>
<span class="comments">;      </span>
<span class="comments">;      0 uses the default special values</span>
<span class="comments">;      </span>
<span class="comments">;      1 uses the special values found in the header</span>
<span class="comments">;      </span>
<span class="comments">;      2 disables special value replacement</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    See the example on pp_readcube__define.</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Oct/2009</span>
<span class="comments">;-</span>
<a id="pp_readcube::init:source"></a>function pp_readcube::init,file,special=special
compile_opt idl2,hidden

<span class="comments">;Defaults</span>
special=n_elements(special) eq 1 ? special : 0B
self.special=special

ret=0
if (n_elements(file) ne 1) then begin
  print,'pp_readcube: Cube name not provided'
  return,ret
endif else if (file eq '') then return,ret <span class="comments">;Silently get out to allow the trick in pp_cubecollection::init</span>
header=obj_new('pp_buffered_vector')
history=obj_new('pp_buffered_vector')
error_status=0<span class="comments">;catch,error_status</span>
if (error_status ne 0) then begin
  catch,/cancel
  print,'pp_readcube: Cube named "',file,'" could not be read or parsed'
endif else begin
  self.file=file
<span class="comments">;Read the header</span>
  openr,unit,file,/get_lun
  line=''
<span class="comments">;Test for a valid cube</span>
  readf,unit,line
<span class="comments">;First line must start with 'CCSD'</span>
  if (strpos(line,'CCSD') ne 0) then print,'pp_readcube: "',file,'" does not appear to be a valid cube' else begin 
<span class="comments">;Cube seems to be valid, so proceed reading header</span>
    header->append,line
    repeat begin
      if (not eof(unit)) then readf,unit,line else begin
        print,'pp_readcube: "',file,'" does not appear to be a valid cube' <span class="comments">;Header must end before the file ends</span>
        break
      endelse
      header->append,line
    endrep until (strtrim(line,2) eq 'END')
<span class="comments">;Get a string array from the header object</span>
    self.labels=ptr_new(header->getdata(/all))
    self.tlabels=ptr_new(strtrim(*self.labels,2))
<span class="comments">;Parse the labels</span>
    if self->parselabels() then begin
<span class="comments">;Get the history part</span>
      if ((self.info.filerecords-self.info.labelrecords) gt 0) then begin
        point_lun,unit,self.info.recordbytes*self.info.historystart
        repeat begin
          if (not eof(unit)) then readf,unit,line else begin
            print,'pp_readcube: "',file,'" does not appear to be a valid cube' <span class="comments">;Header must end before the file ends</span>
            break
          endelse
          history->append,line
        endrep until (strtrim(line,2) eq 'END')
<span class="comments">;Get a string array from the header object</span>
        self.history=ptr_new(history->getdata(/all))
        self.thistory=ptr_new(strtrim(*self.history,2))
      endif            
<span class="comments">;Get the binary part</span>
      raw=make_array(self.info.dims,type=self.info.datatype,/nozero)
      point_lun,unit,self.info.recordbytes*self.info.binarystart
      readu,unit,raw
      self.raw=ptr_new(raw,/no_copy)
    endif else message,'"'+file+'" does not appear to have enough information in its header'
  endelse
<span class="comments">;Process the data</span>
  self->processdata
  ret=1
endelse
catch,/cancel
if (n_elements(unit) eq 1) then free_lun,unit
obj_destroy,header
obj_destroy,history
return,ret
end

<a id="pp_readcube::cleanup:source"></a>pro pp_readcube::cleanup
compile_opt idl2,hidden
ptr_free,self.labels,self.tlabels,self.history,self.thistory,self.raw
ptr_free,self.core,self.backplanes,self.sideplanes,self.bottomplanes
ptr_free,self.wavs,self.bnames,self.snames,self.bonames
ptr_free,self.wavs,self.bunits,self.sunits,self.bounits
end

<a id="pp_readcube::parselabels:source"></a>function pp_readcube::parselabels
<span class="comments">;Gets the minimum required information from the header to be able to</span>
<span class="comments">;read the data in the cube.</span>
compile_opt idl2,hidden

<span class="comments">;Get the core and suffix dimensions</span>
theader=*self.tlabels
count=1
self.info.coredims=long(pp_getcubeheadervalue(theader,'CORE_ITEMS',count=tmp)) & count*=tmp
self.info.suffdims=long(pp_getcubeheadervalue(theader,'SUFFIX_ITEMS',count=tmp)) & count*=tmp
self.info.dims=self.info.coredims+self.info.suffdims
<span class="comments">;Determine the data type</span>
self.info.bytes=fix(pp_getcubeheadervalue(theader,'CORE_ITEM_BYTES',count=tmp)) & count*=tmp
self.info.type=pp_getcubeheadervalue(theader,'CORE_ITEM_TYPE',count=tmp) & count*=tmp
if (strpos(self.info.type,'REAL') ne -1) then begin
  case self.info.bytes of
    8 : self.info.datatype=5 <span class="comments">;double </span>
    else : self.info.datatype=4 <span class="comments">;float</span>
  endcase
endif else begin
  case self.info.bytes of
    1 : self.info.datatype=1 <span class="comments">;byte</span>
    2 : self.info.datatype=2 <span class="comments">;int</span>
    8 : self.info.datatype=14 <span class="comments">;long64</span>
    else : self.info.datatype=3 <span class="comments">;long</span>
  endcase
endelse
<span class="comments">;Determine endianness</span>
self.info.littleendian=(strpos(self.info.type,'PC') ne -1)
<span class="comments">;Determine the length and location of the labels, history and data parts</span>
self.info.recordbytes=long(pp_getcubeheadervalue(theader,'RECORD_BYTES',count=tmp)) & count*=tmp
self.info.historystart=long(pp_getcubeheadervalue(theader,'\^HISTORY',count=tmp))-1L & count*=tmp
self.info.binarystart=long(pp_getcubeheadervalue(theader,'\^QUBE',count=tmp))-1L & count*=tmp
self.info.filerecords=long(pp_getcubeheadervalue(theader,'FILE_RECORDS',count=tmp))-1L & count*=tmp
self.info.labelrecords=long(pp_getcubeheadervalue(theader,'LABEL_RECORDS',count=tmp))-1L & count*=tmp
self.info.historyrecords=self.info.filerecords-self.info.labelrecords
self.info.binaryrecords=self.info.filerecords-self.info.binarystart-1

<span class="comments">;Get the core wavelengths</span>
wavs=double(pp_getcubeheadervalue(theader,'BAND_BIN_CENTER',count=tmp))
wavs=tmp gt 0 ? wavs : replicate('UNKNOWN',self.info.coredims[2])
self.wavs=ptr_new(wavs,/no_copy)
<span class="comments">;Get the core units</span>
units=pp_getcubeheadervalue(theader,'BAND_BIN_UNIT',count=tmp)
self.units=tmp gt 0 ? units : ''
<span class="comments">;Get the backplane names</span>
if (self.info.suffdims[2] gt 0) then begin
  bnames=pp_getcubeheadervalue(theader,'BAND_SUFFIX_NAME',count=tmp)
  bnames=tmp gt 0 ? bnames : 'UNKNOWN_'+strtrim(sindgen(self.info.suffdims[2]),2)
  self.bnames=ptr_new(bnames,/no_copy)
<span class="comments">;Get the backplane unit names</span>
  bunits=pp_getcubeheadervalue(theader,'BAND_SUFFIX_UNIT',count=tmp)
  bunits=tmp gt 0 ? bunits : replicate('UNKNOWN',self.info.suffdims[2])
  self.bunits=ptr_new(bunits,/no_copy)
endif
<span class="comments">;Get the sideplane names</span>
if (self.info.suffdims[0] gt 0) then begin
  snames=pp_getcubeheadervalue(theader,'SAMPLE_SUFFIX_NAME',count=tmp)
  snames=tmp gt 0 ? snames : 'UNKNOWN_'+strtrim(sindgen(self.info.suffdims[0]),2)
  self.snames=ptr_new(snames,/no_copy)
<span class="comments">;Get the sideplane unit names</span>
  sunits=pp_getcubeheadervalue(theader,'SAMPLE_SUFFIX_UNIT',count=tmp)
  sunits=tmp gt 0 ? sunits : replicate('UNKNOWN',self.info.suffdims[0])
  self.sunits=ptr_new(sunits,/no_copy)
endif
<span class="comments">;Get the bottomplane names</span>
if (self.info.suffdims[1] gt 0) then begin
  bonames=pp_getcubeheadervalue(theader,'LINE_SUFFIX_NAME',count=tmp)
  bonames=tmp gt 0 ? bonames : 'UNKNOWN_'+strtrim(sindgen(self.info.suffdims[1]),2)
  self.bonames=ptr_new(bonames,/no_copy)
<span class="comments">;Get the bottomplane unit names</span>
  bounits=pp_getcubeheadervalue(theader,'LINE_SUFFIX_UNIT',count=tmp)
  bounits=tmp gt 0 ? bounits : replicate('UNKNOWN',self.info.suffdims[1])
  self.bounits=ptr_new(bounits,/no_copy)
endif

return,(count ne 0) <span class="comments">;A return value of 0 indicates failure to read all the required information</span>
end

<a id="pp_readcube::processdata:source"></a>pro pp_readcube::processdata
<span class="comments">;Extracts the core and suffix parts of the raw data, swaps bytes if necessary,</span>
<span class="comments">;and does special value replacement if selected.</span>
compile_opt idl2,hidden

cdims=self.info.coredims
sdims=self.info.suffdims

<span class="comments">;Get the core</span>
core=(*self.raw)[0:cdims[0]-1,0:cdims[1]-1,0:cdims[2]-1]
<span class="comments">;Get the suffix</span>
back=(sdims[2] gt 0) <span class="comments">;Are there backplanes?</span>
side=(sdims[0] gt 0) <span class="comments">;Are there sideplanes?</span>
bottom=(sdims[1] gt 0) <span class="comments">;Are there bottomplanes?</span>
if back then backplanes=(*self.raw)[0:cdims[0]-1,0:cdims[1]-1,cdims[2]:cdims[2]+sdims[2]-1]
if side then sideplanes=(*self.raw)[cdims[0]:cdims[0]+sdims[0]-1,0:cdims[1]-1,0:cdims[2]-1]
if bottom then bottomplanes=(*self.raw)[0:cdims[0]-1,cdims[1]:cdims[1]+sdims[1]-1,0:cdims[2]-1]

<span class="comments">;Swap byte order if necessary</span>
l_e=self.info.littleendian
b_e=~l_e
byteorder,core,swap_if_big_endian=l_e,swap_if_little_endian=b_e
if back then byteorder,backplanes,swap_if_big_endian=l_e,swap_if_little_endian=b_e
if side then byteorder,sideplanes,swap_if_big_endian=l_e,swap_if_little_endian=b_e
if bottom then byteorder,bottomplanes,swap_if_big_endian=l_e,swap_if_little_endian=b_e

<span class="comments">;Replace special values, if requested</span>
if (self.special eq 0) || (self.special eq 1) then begin
  special=self->getspecialvalues()
  core=pp_readcube_specialreplace(core,special)
  if back then backplanes=pp_readcube_specialreplace(backplanes,special)
  if side then sideplanes=pp_readcube_specialreplace(sideplanes,special)
  if bottom then bottomplanes=pp_readcube_specialreplace(bottomplanes,special)
endif

<span class="comments">;Store the processed data</span>
self.core=ptr_new(core,/no_copy)
if back then self.backplanes=ptr_new(backplanes,/no_copy)
if side then self.sideplanes=ptr_new(sideplanes,/no_copy)
if bottom then self.bottomplanes=ptr_new(bottomplanes,/no_copy)

end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Provides a structure with the special values to use in this cube,</span>
<span class="comments">;    determined by the special replacement mode selected when the object</span>
<span class="comments">;    was created (see documentation of the init method).</span>
<span class="comments">;</span>
<span class="comments">; :Returns:</span>
<span class="comments">;    A structure where each field is one of the six special values:</span>
<span class="comments">;    VALID_MIN,NULL,LOW_REPR_SAT,LOW_INSTR_SAT,HIGH_INSTR_SAT,HIGH_REPR_SAT</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Oct/2009</span>
<span class="comments">;-</span>
<a id="pp_readcube::getspecialvalues:source"></a>function pp_readcube::getspecialvalues,default=default
compile_opt idl2

default=n_elements(default) eq 1 ? default : 0

<span class="comments">;Constants</span>
<span class="comments">;Default special values (from ISIS' SpecialPixel.h)</span>
<span class="comments">;8-byte:</span>
special_8={VALID_MIN:'FEFFFFFFFFFFFFA'xull,$
 NULL:'FFEFFFFFFFFFFFFB'xull,$
 LOW_REPR_SAT:'FFEFFFFFFFFFFFFC'xull,$
 LOW_INSTR_SAT:'FFEFFFFFFFFFFFFD'xull,$
 HIGH_INSTR_SAT:'FFEFFFFFFFFFFFFE'xull,$
 HIGH_REPR_SAT:'FFEFFFFFFFFFFFFF'xull}
<span class="comments">;4-byte:</span>
special_4={VALID_MIN:'FF7FFFFA'xul,$
 NULL:'FF7FFFFB'xul,$
 LOW_REPR_SAT:'FF7FFFFC'xul,$
 LOW_INSTR_SAT:'FF7FFFFD'xul,$
 HIGH_INSTR_SAT:'FF7FFFFE'xul,$
 HIGH_REPR_SAT:'FF7FFFFF'xul}
<span class="comments">;2-byte:</span>
special_2={VALID_MIN:-32752S,$
 NULL:fix(-32768),$
 LOW_REPR_SAT:-32767S,$
 LOW_INSTR_SAT:-32766S,$
 HIGH_INSTR_SAT:-32765S,$
 HIGH_REPR_SAT:-32764S,$
 VALID_MAX:32767S}
<span class="comments">;1-byte:</span>
special_1={VALID_MIN:1B,$
 NULL:0B,$
 LOW_REPR_SAT:0B,$
 LOW_INSTR_SAT:0B,$
 HIGH_INSTR_SAT:255B,$
 HIGH_REPR_SAT:255B,$
 VALID_MAX:254B}

sel=default ? 0 : self.special
switch sel of
 1 : begin <span class="comments">;Get the set of special values from the header</span>
   theader=*self.theader
   count=1
   vmin=pp_getcubeheadervalue(theader,'CORE_VALID_MINIMUM',count=tmp) & count*=tmp
   null=pp_getcubeheadervalue(theader,'CORE_NULL',count=tmp) & count*=tmp
   lrs=pp_getcubeheadervalue(theader,'CORE_LOW_REPR_SATURATION',count=tmp) & count*=tmp
   lis=pp_getcubeheadervalue(theader,'CORE_LOW_INSTR_SATURATION',count=tmp) & count*=tmp
   hrs=pp_getcubeheadervalue(theader,'CORE_HIGH_REPR_SATURATION',count=tmp) & count*=tmp
   his=pp_getcubeheadervalue(theader,'CORE_HIGH_INSTR_SATURATION',count=tmp) & count*=tmp
   if (count ne 0) then begin
     if (self.info.bytes ge 4) then begin <span class="comments">;Special values that are written in hex</span>
       tmp=self.info.bytes eq 8 ? 0ULL : 0UL
       reads,vmin,ltmp,format='(3X,Z,1X)' & vmin=ltmp
       reads,null,ltmp,format='(3X,Z,1X)' & null=ltmp
       reads,lrs,ltmp,format='(3X,Z,1X)' & lrs=ltmp
       reads,lis,ltmp,format='(3X,Z,1X)' & lis=ltmp
       reads,hrs,ltmp,format='(3X,Z,1X)' & hrs=ltmp
       reads,his,ltmp,format='(3X,Z,1X)' & his=ltmp
     endif
     case self.info.bytes of <span class="comments">;Select the proper processing of the values</span>
      1 : special={VALID_MIN:byte(vmin),NULL:byte(null),LOW_REPR_SAT:byte(lrs),$
           LOW_INSTR_SAT:byte(lis),HIGH_INSTR_SAT:byte(his),HIGH_REPR_SAT:byte(hrs)}
      2 : special={VALID_MIN:fix(vmin),NULL:fix(null),LOW_REPR_SAT:fix(lrs),$
           LOW_INSTR_SAT:fix(lis),HIGH_INSTR_SAT:fix(his),HIGH_REPR_SAT:fix(hrs)}
      8 : special={VALID_MIN:vmin,NULL:null,LOW_REPR_SAT:lrs,$
           LOW_INSTR_SAT:lis,HIGH_INSTR_SAT:his,HIGH_REPR_SAT:hrs}
      else : special={VALID_MIN:vmin,NULL:null,LOW_REPR_SAT:lrs,$
              LOW_INSTR_SAT:lis,HIGH_INSTR_SAT:his,HIGH_REPR_SAT:hrs}
     endcase
     break
<span class="comments">;If header does not provide enough information, fall through to defaults</span>
   endif else print,'pp_readcube: Warning: Cube header does not have all special values, using default values'
 end
 else : begin
   case self.info.bytes of <span class="comments">;Select the proper default set of special values</span>
    1 : special=special_1
    2 : special=special_2
    8 : special=special_8
    else : special=special_4
   endcase
   self.special=0
 end
endswitch
return,special
end

<a id="pp_readcube_specialreplace:source"></a>function pp_readcube_specialreplace,data,special
<span class="comments">;Given a structure special containing the special values (as returned by pp_readcube::getspecial),</span>
<span class="comments">;replaces the occurrences of special values in the array data by NaN (real types),</span>
<span class="comments">;or special.null (integer types). </span>
compile_opt idl2,hidden
datatype=size(data,/type)
  case datatype of <span class="comments">;Reals are treated differently from integers</span>
   4 : begin <span class="comments">;Floats</span>
     rep=!values.f_nan
     w=where(data lt float(special.valid_min,0),count)
     if (count gt 0) then data[w]=rep
     sel=(data eq float(special.null,0))
     sel=sel or (data eq float(special.low_repr_sat,0))
     sel=sel or (data eq float(special.low_instr_sat,0))
     sel=sel or (data eq float(special.high_instr_sat,0))
     sel=sel or (data eq float(special.high_repr_sat,0))
     w=where(sel,count)
     if (count gt 0) then data[w]=rep
   end
   5 : begin <span class="comments">;Doubles</span>
     rep=!values.d_nan
     w=where(data lt double(special.valid_min,0),count)
     if (count gt 0) then data[w]=rep
     sel=(data eq double(special.null,0))
     sel=sel or (data eq double(special.low_repr_sat,0))
     sel=sel or (data eq double(special.low_instr_sat,0))
     sel=sel or (data eq double(special.high_instr_sat,0))
     sel=sel or (data eq double(special.high_repr_sat,0))
     w=where(sel,count)
     if (count gt 0) then data[w]=rep
   end
   else : begin <span class="comments">;Integers</span>
     rep=special.null
     w=where(data lt special.valid_min,count)
     if (count gt 0) then data[w]=rep
     sel=(data eq special.null)
     sel=sel or (data eq special.low_repr_sat)
     sel=sel or (data eq special.low_instr_sat)
     sel=sel or (data eq special.high_instr_sat)
     sel=sel or (data eq special.high_repr_sat)
     w=where(sel,count)
     if (count gt 0) then data[w]=rep     
   end
  endcase
return,data
end

<a id="pp_readcube::getexerpt:source"></a>function pp_readcube::getexerpt
compile_opt idl2,logical_predicate
nx=self.info.coredims[0]
nz=self.info.coredims[1]
npixels=nx*nz
ret=replicate({x:0,z:0,lats:dblarr(4)+!values.d_nan,lons:dblarr(4)+!values.d_nan,lat:!values.d_nan,$
  lon:!values.d_nan,emissions:dblarr(4)+!values.d_nan,phases:dblarr(4)+!values.d_nan,incidences:$
  dblarr(4)+!values.d_nan,az_difs:dblarr(4)+!values.d_nan,emission:!values.d_nan,phase:!values.d_nan,$
  incidence:!values.d_nan,az_dif:!values.d_nan},npixels)
lats=reform(self.getsuffixbyname('LAT_'+strtrim(indgen(5),2)),npixels,5)
lons=reform(self.getsuffixbyname('LON_'+strtrim(indgen(5),2)),npixels,5)
emissions=reform(self.getsuffixbyname('EMISSION_'+strtrim(indgen(5),2)),npixels,5)
phases=reform(self.getsuffixbyname('PHASE_'+strtrim(indgen(5),2)),npixels,5)
incidences=reform(self.getsuffixbyname('INCIDENCE_'+strtrim(indgen(5),2)),npixels,5)
az_difs=reform(self.getsuffixbyname('AZ_DIF_'+strtrim(indgen(5),2)),npixels,5)
x=(indgen(nx)+1)#replicate(1,nz)
z=replicate(1,nx)#(indgen(nz)+1)
x=reform(x,npixels)
z=reform(z,npixels)
ret.x=x & ret.z=z
ret.lat=lats[*,0]
ret.lon=lons[*,0]
ret.incidence=incidences[*,0]
ret.phase=phases[*,0]
ret.emission=emissions[*,0]
ret.az_dif=az_difs[*,0]
ret.lats=transpose(lats[*,1:4])
ret.lons=transpose(lons[*,1:4])
ret.incidences=transpose(incidences[*,1:4])
ret.phases=transpose(phases[*,1:4])
ret.emissions=transpose(emissions[*,1:4])
ret.az_difs=transpose(az_difs[*,1:4])
return,ret
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Retrieves parts of the data contained in the object. If keyword all is given,</span>
<span class="comments">;    returns all the properties as fields of a structure.</span>
<span class="comments">;</span>
<span class="comments">; :Returns:</span>
<span class="comments">;    See keyword descriptions.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    all : out, optional</span>
<span class="comments">;      A structure containing every property as a field with the same name as the corresponding keyword.</span>
<span class="comments">;    file : out, optional</span>
<span class="comments">;      File from which the cube was read.</span>
<span class="comments">;    special : out, optional</span>
<span class="comments">;      The special value replacement mode used when the data was processed: 0 for default special values,</span>
<span class="comments">;      1 for special values given in the header, 2 for no special value replacement.</span>
<span class="comments">;    labels : out, optional</span>
<span class="comments">;      String array with one element for each line of the label part of the cube header.</span>
<span class="comments">;    history : out, optional</span>
<span class="comments">;      String array with one element for each line of the history part of the cube header. </span>
<span class="comments">;    core : out, optional</span>
<span class="comments">;      3D array with the core data values.</span>
<span class="comments">;    backplanes : out, optional</span>
<span class="comments">;      3D array with the backplane values, if there are blackplanes, a null pointer otherwise.</span>
<span class="comments">;    sideplanes : out, optional</span>
<span class="comments">;      3D array with the sideplane values, if there are sideplanes, a null pointer otherwise.</span>
<span class="comments">;    bottomplanes : out, optional</span>
<span class="comments">;      3D array with the bottomplane values, if there are bottomplanes, a null pointer otherwise.</span>
<span class="comments">;    info : out, optional</span>
<span class="comments">;      A structure with the cube parameters that were used to read it.</span>
<span class="comments">;    lines : out, optional</span>
<span class="comments">;      The number of lines in the core.</span>
<span class="comments">;    bands : out, optional</span>
<span class="comments">;      The number of bands in the core.</span>
<span class="comments">;    samples : out, optional</span>
<span class="comments">;      The number of samples in the core.</span>
<span class="comments">;    nback : out, optional</span>
<span class="comments">;      The number of backplanes in the suffix.</span>
<span class="comments">;    nside : out, optional</span>
<span class="comments">;      The number of sideplanes in the suffix.</span>
<span class="comments">;    nbottom : out, optional</span>
<span class="comments">;      The number of bottomplanes in the suffix.</span>
<span class="comments">;    rawdata : out, optional</span>
<span class="comments">;      The unprocessed binary part of the cube.</span>
<span class="comments">;    wavelengths : out, optional</span>
<span class="comments">;      A string array with the wavelength of each core band ('UNKNOWN's if not found).</span>
<span class="comments">;    backnames : out, optional</span>
<span class="comments">;      A string array with the name of each backplane ('UNKNOWN_'+sindgen(nback) if not found).</span>
<span class="comments">;    sidenames : out, optional</span>
<span class="comments">;      A string array with the name of each sideplane ('UNKNOWN_'+sindgen(nside) if not found).</span>
<span class="comments">;    bottomnames : out, optional</span>
<span class="comments">;      A string array with the name of each bottomplane ('UNKNOWN_'+sindgen(nbottom) if not found).</span>
<span class="comments">;    units : out, optional</span>
<span class="comments">;      A string with the wavelength unit of the core bands ('UNKNOWN' if not found).</span>
<span class="comments">;    backunits : out, optional</span>
<span class="comments">;      A string array with the name of each backplane's unit ('UNKNOWN's if not found).</span>
<span class="comments">;    sideunits : out, optional</span>
<span class="comments">;      A string array with the name of each sideplane's unit ('UNKNOWN's if not found).</span>
<span class="comments">;    bottomunits : out, optional</span>
<span class="comments">;      A string array with the name of each bottomplane's unit ('UNKNOWN's if not found).</span>
<span class="comments">;    struct_backplanes : out, optional</span>
<span class="comments">;      2D array of structures, each with one field for each backplane, if there are blackplanes, a null pointer otherwise.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    See the example on pp_readcube__define.</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Oct/2009</span>
<span class="comments">;-</span>
<a id="pp_readcube::getproperty:source"></a>pro pp_readcube::getproperty,all=all,file=file,special=special,labels=labels,history=history,$
 core=core,backplanes=backplanes,sideplanes=sideplanes,bottomplanes=bottomplanes,$
 info=info,lines=lines,bands=bands,samples=samples,nback=nback,nside=nside,nbottom=nbottom,$
 rawdata=raw,wavelengths=wavs,backnames=bnames,sidenames=snames,bottomnames=bonames,$
 units=wunits,backunits=bunits,sideunits=sunits,bottomunits=bounits,struct_backplanes=struct_backplanes,$
 npixels=npixels,lats=lats,lons=lons
compile_opt idl2

all=arg_present(all)
if (all || arg_present(file)) then file=self.file
if (all || arg_present(special)) then special=self.special
if (all || arg_present(labels)) then labels=*self.labels
if (all || arg_present(history)) then history=*self.history
if (all || arg_present(core)) then core=*self.core
if (all || arg_present(backplanes)) then backplanes=ptr_valid(self.backplanes) ? *self.backplanes : self.backplanes
if (all || arg_present(sideplanes)) then sideplanes=ptr_valid(self.sideplanes) ? *self.sideplanes : self.sideplanes
if (all || arg_present(bottomplanes)) then bottomplanes=ptr_valid(self.bottomplanes) ? *self.bottomplanes : self.bottomplanes
if (all || arg_present(info)) then info=self.info
if (all || arg_present(lines)) then lines=self.info.coredims[1]
if (all || arg_present(samples)) then samples=self.info.coredims[0]
if (all || arg_present(npixels)) then npixels=self.info.coredims[0]*self.info.coredims[1]
if (all || arg_present(bands)) then bands=self.info.coredims[2]
if (all || arg_present(nback)) then nback=self.info.suffdims[2]
if (all || arg_present(nside)) then nside=self.info.suffdims[0]
if (all || arg_present(nbottom)) then nbottom=self.info.suffdims[1]
if (all || arg_present(raw)) then raw=*self.raw
if (all || arg_present(wavs)) then wavs=*self.wavs
if (all || arg_present(bnames)) then bnames=ptr_valid(self.bnames) ? *self.bnames : self.bnames
if (all || arg_present(snames)) then snames=ptr_valid(self.snames) ? *self.snames : self.snames
if (all || arg_present(bonames)) then bonames=ptr_valid(self.bonames) ? *self.bonames : self.bonames
if (all || arg_present(wunits)) then wunits=self.units
if (all || arg_present(bunits)) then bunits=ptr_valid(self.bunits) ? *self.bunits : self.bunits
if (all || arg_present(sunits)) then sunits=ptr_valid(self.sunits) ? *self.sunits : self.sunits
if (all || arg_present(bounits)) then bounits=ptr_valid(self.bounits) ? self.bounits : self.bounits
if (all || arg_present(struct_backplanes)) then begin
  if (ptr_valid(self.bnames)) then begin
  nt=n_elements(*self.bnames)
  tmp=create_struct((*self.bnames)[0],0d0)
  for i=1,nt-1 do tmp=create_struct(tmp,(*self.bnames)[i],0d0)
  struct_backplanes=replicate(tmp,self.info.coredims[0],self.info.coredims[1],self.info.suffdims[2])
  for i=0,nt-1 do struct_backplanes[*,*].(i)=(*self.backplanes)[*,*,i]
  endif else struct_backplanes=ptr_new()
endif

if arg_present(lats) then begin
  lats=self[['lat_1','lat_2','lat_3','lat_4']]
  self.getproperty,npixels=np
  lats=reform(lats,np,4)
  lats=transpose(lats)
endif

if arg_present(lons) then begin
  lons=self[['lon_1','lon_2','lon_3','lon_4']]
  self.getproperty,npixels=np
  lons=reform(lons,np,4)
  lons=transpose(lons)
endif

if all then all={file:file,special:special,labels:labels,history:history,core:core,$
   backplanes:backplanes,sideplanes:sideplanes,bottomplanes:bottomplanes,$
   info:info,lines:lines,samples:samples,bands:bands,$
   nback:nback,nside:nside,nbottom:nbottom,$
   raw:raw,wavelengths:wavs,backnames:bnames,sidenames:snames,bottomnames:bonames,$
   units:wunits,backunits:bunits,sideunits:sunits,bottomunits:bounits,struct_backplanes:struct_backplanes}
   
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Simple function wrapper for the routine method getproperty. Has the same keywords,</span>
<span class="comments">;    and retrieves the same values, but with function semantics instead of routine. Only</span>
<span class="comments">;    one keyword should be set, and the corresponding value is the function's return value.</span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    See the example on pp_readcube__define.</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Oct/2009</span>
<span class="comments">;-</span>
<a id="pp_readcube::getproperty:source"></a>function pp_readcube::getproperty,all=all,file=file,special=special,labels=labels,history=history,$
 core=core,backplanes=backplanes,sideplanes=sideplanes,bottomplanes=bottomplanes,$
 info=info,lines=lines,bands=bands,samples=samples,nback=nback,nside=nside,nbottom=nbottom,$
 rawdata=raw,wavelengths=wavs,backnames=bnames,sidenames=snames,bottomnames=bonames,$
 units=wunits,backunits=bunits,sideunits=sunits,bottomunits=bounits
compile_opt idl2
if keyword_set(all) then self->getproperty,all=ret
if keyword_set(file) then self->getproperty,file=ret
if keyword_set(special) then self->getproperty,special=ret
if keyword_set(labels) then self->getproperty,labels=ret
if keyword_set(history) then self->getproperty,history=ret
if keyword_set(core) then self->getproperty,core=ret
if keyword_set(backplanes) then self->getproperty,backplanes=ret
if keyword_set(sideplanes) then self->getproperty,sideplanes=ret
if keyword_set(bottomplanes) then self->getproperty,bottomplanes=ret
if keyword_set(info) then self->getproperty,info=ret
if keyword_set(lines) then self->getproperty,lines=ret
if keyword_set(bands) then self->getproperty,bands=ret
if keyword_set(samples) then self->getproperty,samples=ret
if keyword_set(nback) then self->getproperty,nback=ret
if keyword_set(nside) then self->getproperty,nside=ret
if keyword_set(nbottom) then self->getproperty,nbottom=ret
if keyword_set(raw) then self->getproperty,rawdata=ret
if keyword_set(wavs) then self->getproperty,wavelengths=ret
if keyword_set(bnames) then self->getproperty,backnames=ret
if keyword_set(snames) then self->getproperty,sidenames=ret
if keyword_set(bonames) then self->getproperty,bottomnames=ret
if keyword_set(wunits) then self->getproperty,units=ret
if keyword_set(bunits) then self->getproperty,backunits=ret
if keyword_set(sunits) then self->getproperty,sideunits=ret
if keyword_set(bounits) then self->getproperty,bottomunits=ret
if keyword_set(all) then self->getproperty,all=ret
return,ret
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Retrieves suffix planes by their names. If all suffix planes, or their names,</span>
<span class="comments">;    are to be retrieved, the getproperty method should be used instead. By default,</span>
<span class="comments">;    backplanes are retrieved, but sideplanes and bottomplanes can be returned if the</span>
<span class="comments">;    corresponding keyword is set.</span>
<span class="comments">;</span>
<span class="comments">; :Returns:</span>
<span class="comments">;    A 2D array (if only one plane is requested) or 3D array (if several planes) with</span>
<span class="comments">;    the names suffix planes. If one plane is not found, the corresponding array plane contains</span>
<span class="comments">;    either NaN (for real types) or special.null (for integer types). </span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    names : in, required</span>
<span class="comments">;      A scalar or string array with the name(s) of the suffix plane(s) to retrieve.</span>
<span class="comments">;      If more than one plane is returned, their order (in the 3rd dimension of the</span>
<span class="comments">;      returned array) is the same as the order of the names in this array.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    found : out, optional</span>
<span class="comments">;      An integer array with the same number of elements as names, with the number</span>
<span class="comments">;      of suffix planes that match each given name. If more than one suffix plane has</span>
<span class="comments">;      the selected name, the first one is the one returned (though proper cubes should</span>
<span class="comments">;      not have multiple planes with the same name).</span>
<span class="comments">;    index : out, optional</span>
<span class="comments">;      An integer array with the same number of elements as names, with the index of the returned</span>
<span class="comments">;      suffix planes that matched each given name. If more than one suffix plane has</span>
<span class="comments">;      the selected name, the first one is the one returned (though proper cubes should</span>
<span class="comments">;      not have multiple planes with the same name). When that plane was not found, the corresponding</span>
<span class="comments">;      index will be -1.</span>
<span class="comments">;    case_sensitive : in, optional, default=0</span>
<span class="comments">;      If set, name matches are case-sensitive (though proper cubes should not have planes</span>
<span class="comments">;      the same name in different capitalizations). </span>
<span class="comments">;    side : in, optional, default=0</span>
<span class="comments">;      By default, the search for the planes is done among the cube's backplanes. If this keyword is</span>
<span class="comments">;      set, sideplanes are used instead.</span>
<span class="comments">;    bottom : in, optional, default=0</span>
<span class="comments">;      By default, the search for the planes is done among the cube's backplanes. If this keyword is</span>
<span class="comments">;      set, bottomplanes are used instead.</span>
<span class="comments">;    back : in, optional, default=1</span>
<span class="comments">;      If set, the search for the planes is done among the cube's backplanes (default).</span>
<span class="comments">;       </span>
<span class="comments">; :Examples:</span>
<span class="comments">;    See the example on pp_readcube__define.</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Oct/2009</span>
<span class="comments">;-</span>
<a id="pp_readcube::getsuffixbyname:source"></a>function pp_readcube::getsuffixbyname,names,found=found,case_sensitive=cases,side=side,bottom=bottom,back=back,index=index
compile_opt idl2

<span class="comments">;Defaults</span>
cases=n_elements(cases) eq 1 ? cases : 0
back=n_elements(back) eq 1 ? back : 1
side=n_elements(side) eq 1 ? side : 0
bottom=n_elements(bottom) eq 1 ? bottom : 0

<span class="comments">;Initialize the return arrays</span>
nnames=n_elements(names)
if (nnames eq 0) then message,'Names for the suffix planes were not provided'
type=back ? 2 : (side ? 0 : (bottom ? 1 : 2))
case type of
  2 : ret=make_array(type=self.info.datatype,[self.info.coredims[[0,1]],nnames],/nozero)
  0 : ret=make_array(type=self.info.datatype,[self.info.coredims[[1,2]],nnames],/nozero)
  1 : ret=make_array(type=self.info.datatype,[self.info.coredims[[0,2]],nnames],/nozero)
endcase
special=self->getspecialvalues()
ret[*]=self.info.datatype eq 4 ? !values.f_nan : (self.info.datatype eq 5 ? !values.d_nan : special.null)
found=intarr(nnames)
index=intarr(nnames)
<span class="comments">;Retrieve the names and values of the proper suffix</span>
sufnames=type eq 2 ? self.bnames : (type eq 0 ? self.snames : self.bonames)
sufvals=type eq 2 ? self.backplanes : (type eq 0 ? self.sideplanes : self.bottomplanes)
if ptr_valid(sufnames) then begin
  csufnames=cases ? *sufnames : strupcase(*sufnames)
  cnames=cases ? names : strupcase(names)
  for i=0,nnames-1 do begin
    if (cnames[i]  eq 'X') or (cnames[i]  eq 'Z') then begin
      if (cnames[i]  eq 'X') then tmp=indgen(self.info.coredims[[0,1]]) mod self.info.coredims[0] 
      if (cnames[i]  eq 'Z') then tmp=reverse(floor(indgen(self.info.coredims[[0,1]]) / self.info.coredims[0]),2)
      ret[0,0,i]=tmp+1
    endif else begin
      w=where((strpos(csufnames,cnames[i]) ne -1),nw)
      found[i]=nw
      index[i]=w[0]
      if (nw gt 0) then ret[0,0,i]=(*sufvals)[*,*,w[0]]
    endelse 
  endfor
endif
return,ret
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Retrieves one or more core bands from their wavelengths. The returned bands</span>
<span class="comments">;    are those with wavelength nearest to the ones provided, so they need not</span>
<span class="comments">;    match exactly.</span>
<span class="comments">;</span>
<span class="comments">; :Returns:</span>
<span class="comments">;    If only one wavelength is provided, returns a 2D array with that band.</span>
<span class="comments">;    If more than one wavelength is provided, the result is a 3D array, with the</span>
<span class="comments">;    3rd dimension being the bands.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    wavs : in, required</span>
<span class="comments">;      A scalar or array with the value(s) of the wavelength(s) to search for. </span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    index : out, optional</span>
<span class="comments">;      Returns the index of the band that matched each provided wavelength.</span>
<span class="comments">;       </span>
<span class="comments">;    wavelengths : out, optional</span>
<span class="comments">;      Returns the wavelength of the band that matched each provided wavelength. </span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    See the example on pp_readcube__define.</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Oct/2009</span>
<span class="comments">;-</span>
<a id="pp_readcube::getbandbywavelength:source"></a>function pp_readcube::getbandbywavelength,wavs,index=inds,wavelengths=sdwavs
compile_opt idl2

nwavs=n_elements(wavs)
if (nwavs eq 0) then message,'Wavelengths were not provided'
<span class="comments">;Make the double array for the wavelengths</span>
catch,error_status
if (error_status ne 0) then begin
  catch,/cancel
  message,'Cube does not contain valid wavelengths'
endif else dwavs=double(*self.wavs)
ndwavs=n_elements(dwavs)
tmp0=rebin(reform(wavs,1,nwavs),ndwavs,nwavs)
tmp1=rebin(dwavs,ndwavs,nwavs)
void=min(tmp0-tmp1,inds,/abs,dim=1,/nan)
inds=reform((array_indices(tmp0,inds))[0,*])
ret=(*self.core)[*,*,inds]
sdwavs=dwavs[inds]
return,ret
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Retrieves one or more core bands from their indexes.</span>
<span class="comments">;</span>
<span class="comments">; :Returns:</span>
<span class="comments">;    If only one index is provided, returns a 2D array with that band.</span>
<span class="comments">;    If more than one index is provided, the result is a 3D array, with the</span>
<span class="comments">;    3rd dimension being the bands.</span>
<span class="comments">;</span>
<span class="comments">; :Params:</span>
<span class="comments">;    index : in, required</span>
<span class="comments">;      A scalar or array with the value(s) of the index(es) to search for. </span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;       </span>
<span class="comments">;    wavelengths : out, optional</span>
<span class="comments">;      Returns the wavelength of the band that matched each provided index. </span>
<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    See the example on pp_readcube__define.</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Oct/2009</span>
<span class="comments">;-</span>
<a id="pp_readcube::getbandbyindex:source"></a>function pp_readcube::getbandbyindex,index,wavelengths=sdwavs
compile_opt idl2

ninds=n_elements(index)
if (ninds eq 0) then message,'Indexes were not provided'
<span class="comments">;Make the double array for the wavelengths</span>
catch,error_status
if (error_status ne 0) then begin
  catch,/cancel
  message,'Cube does not contain given band'
endif else dwavs=double(*self.wavs)
ret=(*self.core)[*,*,index]
sdwavs=dwavs[index]
return,ret
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Retrieves values contained in the label or history part of the cube header.</span>
<span class="comments">;    Just a wrapper for pp_getcubeheadervalue. See its documentation for details.</span>
<span class="comments">;    </span>
<span class="comments">; :Params:</span>
<span class="comments">;    key : in</span>
<span class="comments">;      Key name to be retrieved.</span>
<span class="comments">;</span>
<span class="comments">; :Keywords:</span>
<span class="comments">;    history : in, optional, default=0</span>
<span class="comments">;      If set, reading is done on the history part of the header, instead of the label part.</span>
<span class="comments">;    count : out, optional</span>
<span class="comments">;      Passed to pp_getcubeheadervalue.</span>
<span class="comments">;      The number of occurences of the key found in the header. If more than 1</span>
<span class="comments">;      is found, the last occurence is used. Check this value to determine if</span>
<span class="comments">;      the key was not found (count will be 0 in that case).</span>
<span class="comments">;    fold_case : in, optional</span>
<span class="comments">;      Passed to pp_getcubeheadervalue.</span>
<span class="comments">;      Passed to stregex when searching for the key. If set, capitalization of</span>
<span class="comments">;      the key is ignored.</span>
<span class="comments">;    lines : out, optional</span>
<span class="comments">;      Passed to pp_getcubeheadervalue.</span>
<span class="comments">;      The line index (starting at zero) of the line in the header that provided</span>
<span class="comments">;      the retrieved value. If valued spanned more than one line, this is a vector</span>
<span class="comments">;      with the indexes of all such lines. If key not found, -1 is returned.</span>
<span class="comments">;    unquote : in, optional</span>
<span class="comments">;      Passed to pp_getcubeheadervalue.</span>
<span class="comments">;      If set, enclosing quotes are removed from the return values</span>
<span class="comments">;    sel : in, optional</span>
<span class="comments">;      Passed to pp_getcubeheadervalue.</span>
<span class="comments">;      In case more than one ocurrence of a keyword is found, sel gives the</span>
<span class="comments">;      index of the ocurrence to use (starts at 0). If not set, the last ocurrence</span>
<span class="comments">;      is the one used.</span>

<span class="comments">;</span>
<span class="comments">; :Examples:</span>
<span class="comments">;    See the examples on pp_readcube__define and pp_getcubeheadervalue.</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Oct/2009</span>
<span class="comments">;-</span>
<a id="pp_readcube::getfromheader:source"></a>function pp_readcube::getfromheader,key,history=hist,$
 count=count,fold_case=fold_case,lines=lines,unquote=unquote,sel=sel,cont=cont
compile_opt idl2

<span class="comments">;Defaults</span>
hist=n_elements(hist) eq 1 ? hist : 0
tmp=hist ? *self.thistory : *self.tlabels
ret=pp_getcubeheadervalue(tmp,key,count=count,fold_case=fold_case,lines=lines,unquote=unquote,sel=sel,cont=cont)
return,ret
end

<span class="comments">;+</span>
<span class="comments">; :Description:</span>
<span class="comments">;    Simple overloading to retrieve core bands, backplanes, or wavelenghts from the cube.</span>
<span class="comments">;    </span>
<span class="comments">;    Only 1D is processed. If more than 1D is specified, !null is returned.</span>
<span class="comments">;</span>
<span class="comments">; :Returns:</span>
<span class="comments">; </span>
<span class="comments">;    The returned value depends on the type of the index provided:</span>
<span class="comments">;</span>
<span class="comments">;    If the index is an integer type (including a range), a 2D or 3D array is returned,</span>
<span class="comments">;    with the corresponding core band(s).</span>
<span class="comments">;    </span>
<span class="comments">;    If the index is of string type, then a 2D or 3D array with the corresponsing</span>
<span class="comments">;    backplane(s) is returned.</span>
<span class="comments">;    </span>
<span class="comments">;    If the index is of type double, a 2D or 3D array is returned with the core bands</span>
<span class="comments">;    that have wavelength(s) closest to the wavelength(s) given by the subscript.</span>
<span class="comments">;    </span>
<span class="comments">;    If the index is of type float, a 1D array is returned with the core wavelengths</span>
<span class="comments">;    that are nearest to the correspoinding given wavelength(s).</span>
<span class="comments">;    </span>
<span class="comments">; :Examples:</span>
<span class="comments">;    See the example on pp_readcube__define.</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Feb/2011</span>
<span class="comments">;-</span>
<a id="pp_readcube::_overloadBracketsRightSide:source"></a>function pp_readcube::_overloadBracketsRightSide, isRange, sub1, $
   sub2, sub3, sub4, sub5, sub6, sub7, sub8
compile_opt idl2,logical_predicate

if (n_elements(isrange) ne 1) then return,!null
if (isrange[0]) then begin
  core=self.getproperty(/core)
  ret=core[*,*,sub1[0]:sub1[1]:sub1[2]]
  return,ret
endif
case 1 of
  isa(sub1,'string') : ret=self.getsuffixbyname(sub1)
  isa(sub1,'double') : ret=self.getbandbywavelength(sub1)
  isa(sub1,'float') : !null=self.getbandbywavelength(sub1,wavelengths=ret)
  isa(sub1,'int') || isa(sub1,'uint') || isa(sub1,'long') || isa(sub1,'ulong') || $
   isa(sub1,'long64') || isa(sub1,'ulong64') : ret=self.getbandbyindex(sub1)  
  else: ret=!null
endcase
return,ret
end

<span class="comments">;+</span>
<span class="comments">; </span>
<span class="comments">; :Description:</span>
<span class="comments">;    Object to read an ISIS cube.</span>
<span class="comments">;    </span>
<span class="comments">;    Initialization parses the cube into the object, other methods retrieve parts of it.</span>
<span class="comments">;    </span>
<span class="comments">;    Assumes that all suffix items are the same data type as core items.</span>
<span class="comments">;    </span>
<span class="comments">;    Assumes that cube has 3 axes in BSQ order.</span>
<span class="comments">;    </span>
<span class="comments">;    Assumes constant length records.</span>
<span class="comments">;    </span>
<span class="comments">;    The only methods intended to be public are getproperty,getspecialvalues, getfromheader,</span>
<span class="comments">;    getsuffixbyname, and getbandbywavelength.</span>
<span class="comments">;    </span>
<span class="comments">; :Examples:</span>
<span class="comments">;    </span>
<span class="comments">;    To read the cube CM_1553510065_1_ir.cub::</span>
<span class="comments">; </span>
<span class="comments">;      a=obj_new('pp_readcube','CM_1553510065_1_ir.cub')</span>
<span class="comments">;    </span>
<span class="comments">;    To get the core and its wavelengths::</span>
<span class="comments">;    </span>
<span class="comments">;      a->getproperty,core=core,wavelengths=wavs</span>
<span class="comments">;      print,min(wavs,max=mw),mw</span>
<span class="comments">;      ;0.88421000       5.1225000</span>
<span class="comments">;      </span>
<span class="comments">;    To get the backplanes and their names::</span>
<span class="comments">;    </span>
<span class="comments">;      a->getproperty,backplanes=back,backnames=bnames</span>
<span class="comments">;      print,bnames</span>
<span class="comments">;      ;LATITUDE LONGITUDE SAMPLE_RESOLUTION LINE_RESOLUTION PHASE_ANGLE INCIDENCE_ANGLE EMISSION_ANGLE NORTH_AZIMUTH</span>
<span class="comments">;      </span>
<span class="comments">;    To get the file name::</span>
<span class="comments">;    </span>
<span class="comments">;      print,a->getproperty(/file)</span>
<span class="comments">;      ;CM_1553510065_1_ir.cub</span>
<span class="comments">;      </span>
<span class="comments">;    To get all the properties at once::</span>
<span class="comments">;    </span>
<span class="comments">;     a->getproperty,all=a_all</span>
<span class="comments">;     ;** Structure PP_READCUBE_ALL, 24 tags, length=98912, data length=98895:</span>
<span class="comments">;     ;   FILE            STRING    'CM_1553510065_1_ir.cub'</span>
<span class="comments">;     ;   SPECIAL         BYTE         0</span>
<span class="comments">;     ;   LABELS          STRING    Array[268]</span>
<span class="comments">;     ;   HISTORY         STRING    Array[479]</span>
<span class="comments">;     ;   CORE            FLOAT     Array[1, 40, 256]</span>
<span class="comments">;     ;   BACKPLANES      FLOAT     Array[1, 40, 8]</span>
<span class="comments">;     ;   SIDEPLANES      POINTER   &lt;NullPointer></span>
<span class="comments">;     ;   BOTTOMPLANES    POINTER   &lt;NullPointer></span>
<span class="comments">;     ;   INFO            STRUCT    -> PP_READCUBE_INFO Array[1]</span>
<span class="comments">;     ;   LINES           LONG                40</span>
<span class="comments">;     ;   SAMPLES         LONG                 1</span>
<span class="comments">;     ;   BANDS           LONG               256</span>
<span class="comments">;     ;   NBACK           LONG                 8</span>
<span class="comments">;     ;   NSIDE           LONG                 0</span>
<span class="comments">;     ;   NBOTTOM         LONG                 0</span>
<span class="comments">;     ;   RAW             FLOAT     Array[1, 40, 264]</span>
<span class="comments">;     ;   WAVELENGTHS     DOUBLE    Array[256]</span>
<span class="comments">;     ;   BACKNAMES       STRING    Array[8]</span>
<span class="comments">;     ;   SIDENAMES       POINTER   &lt;NullPointer></span>
<span class="comments">;     ;   BOTTOMNAMES     POINTER   &lt;NullPointer></span>
<span class="comments">;     ;   UNITS           STRING    'MICROMETER'</span>
<span class="comments">;     ;   BACKUNITS       STRING    Array[8]</span>
<span class="comments">;     ;   SIDEUNITS       POINTER   &lt;NullPointer></span>
<span class="comments">;     ;   BOTTOMUNITS     POINTER   &lt;NullPointer></span>
<span class="comments">;     </span>
<span class="comments">;    To get the latitudes::</span>
<span class="comments">;    </span>
<span class="comments">;      lats=a->getsuffixbyname('LATITUDE')</span>
<span class="comments">;      </span>
<span class="comments">;    Or, equivalenty::</span>
<span class="comments">;    </span>
<span class="comments">;      lats=a['LATITUDE']</span>
<span class="comments">;      </span>
<span class="comments">;    To get the band with wavelength nearest to 2.1 (in the units used in the cube)::</span>
<span class="comments">;    </span>
<span class="comments">;      selband=a->getbandbywavelength(2.1,wavelengths=selwavs)      </span>
<span class="comments">;      print,selwavs</span>
<span class="comments">;      ;2.1003400</span>
<span class="comments">;      </span>
<span class="comments">;    Or, equivalently::</span>
<span class="comments">;    </span>
<span class="comments">;      selband=a[2.1d0]</span>
<span class="comments">;      selwavs=a[2.1]</span>
<span class="comments">;      print,selwavs</span>
<span class="comments">;      ;2.1003400</span>
<span class="comments">;      </span>
<span class="comments">;    To get the start time of the cube::</span>
<span class="comments">;    </span>
<span class="comments">;      print,a->getfromheader('START_TIME')</span>
<span class="comments">;      ;"2007-084T10:00:57.286Z"</span>
<span class="comments">;</span>
<span class="comments">;    Destroy the object when done with it::</span>
<span class="comments">;    </span>
<span class="comments">;      obj_destroy,a</span>
<span class="comments">;    </span>
<span class="comments">; :Uses: pp_getcubeheadervalue, pp_extractfields</span>
<span class="comments">;</span>
<span class="comments">; :Author: Paulo Penteado (pp.penteado@gmail.com), Oct/2009</span>
<span class="comments">;-</span>
<a id="pp_readcube__define:source"></a>pro pp_readcube__define
compile_opt idl2
void={pp_readcube,$
 file:'',$ <span class="comments">;file name</span>
 special:0B,$ <span class="comments">;Type of special value replacement: 0 for default values, 1 for header values, 2 for no replacement</span>
 labels:ptr_new(),tlabels:ptr_new(),$ <span class="comments">;label part of the header and its trimmed version (string arrays)</span>
 history:ptr_new(),thistory:ptr_new(),$ <span class="comments">;history part of the header and its trimmed version (string arrays)</span>
 raw:ptr_new(),$ <span class="comments">;raw data (array of whatever type used) part</span>
 info:{pp_readcube_info,datatype:0,littleendian:1B,$ <span class="comments">;type code and endianness of the data (assumed same in core and suffix)</span>
 recordbytes:0L,filerecords:0L,labelrecords:0L,historyrecords:0L,binaryrecords:0L,$ <span class="comments">;record length (bytes) and number of records</span>
 historystart:0L,binarystart:0L,$ <span class="comments">;record where the history and binary parts begin </span>
 bytes:0B,type:'',$ <span class="comments">;number of bytes per element, and ISIS type identifier</span>
 dims:lonarr(3),coredims:lonarr(3),suffdims:lonarr(3)},$ <span class="comments">;dimensions of entire cube, and of core and suffix parts  </span>
 core:ptr_new(),backplanes:ptr_new(),sideplanes:ptr_new(),bottomplanes:ptr_new(),$ <span class="comments">;sections of data part</span>
 wavs:ptr_new(),units:'UNKNOWN',$ <span class="comments">;wavelength and units of each core band</span>
 bnames:ptr_new(),snames:ptr_new(),bonames:ptr_new(),$ <span class="comments">;name of each backplane, sideplane and bottomplane</span>
 bunits:ptr_new(),sunits:ptr_new(),bounits:ptr_new(),$ <span class="comments">;units of each backplane, sideplane and bottomplane</span>
 dwavs:ptr_new(),idwavs:ptr_new(),$ <span class="comments">;wavelengths as doubles and their sort indexes</span>
 inherits IDL_Object}
return
end
</code>
    </div>
  </body>
</html>